<!DOCTYPE html><html class="theme-next muse use-motion" lang="zh-Hans"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><script src="/lib/pace/pace.min.js?v=1.0.2"></script><link href="/lib/pace/pace-theme-minimal.min.css?v=1.0.2" rel="stylesheet"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"><link href="//fonts.loli.net/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css"><link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css"><link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css"><meta name="keywords" content="Dart,"><link rel="shortcut icon" type="image/x-icon" href="/favicon.png?v=5.1.1"><meta name="description" content="推荐图书：Dart编程语言 - 【美】Gilad Bracha  推荐阅读官方文档：A Tour of the Dart Language 建议切一个窗口打开DartPad边看边码，更能加深印象！   写在前面Dart 其实并不算一门非常新的语言，最早版本发行与 2011 年 10 月，目标是取代 JavaScript 成为下一代 Web 开发语言（很显然他失败了）。截止发稿已经发布了 2."><meta name="keywords" content="Dart"><meta property="og:type" content="article"><meta property="og:title" content="Dart 简单入门"><meta property="og:url" content="http://blog.rsuitejs.com/2019/02/02/dart/index.html"><meta property="og:site_name" content="HYPERS 前端团队博客"><meta property="og:description" content="推荐图书：Dart编程语言 - 【美】Gilad Bracha  推荐阅读官方文档：A Tour of the Dart Language 建议切一个窗口打开DartPad边看边码，更能加深印象！   写在前面Dart 其实并不算一门非常新的语言，最早版本发行与 2011 年 10 月，目标是取代 JavaScript 成为下一代 Web 开发语言（很显然他失败了）。截止发稿已经发布了 2."><meta property="og:locale" content="zh-Hans"><meta property="og:image" content="http://blog.rsuitejs.com/2019/02/02/dart/logo.png"><meta property="og:updated_time" content="2019-02-14T04:30:39.232Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="Dart 简单入门"><meta name="twitter:description" content="推荐图书：Dart编程语言 - 【美】Gilad Bracha  推荐阅读官方文档：A Tour of the Dart Language 建议切一个窗口打开DartPad边看边码，更能加深印象！   写在前面Dart 其实并不算一门非常新的语言，最早版本发行与 2011 年 10 月，目标是取代 JavaScript 成为下一代 Web 开发语言（很显然他失败了）。截止发稿已经发布了 2."><meta name="twitter:image" content="http://blog.rsuitejs.com/2019/02/02/dart/logo.png"><script type="text/javascript" id="hexo.configurations">var NexT=window.NexT||{},CONFIG={root:"/",scheme:"Muse",sidebar:{position:"left",display:"post",offset:12,offset_float:0,b2t:!1,scrollpercent:!1,onmobile:!1},fancybox:!0,motion:!0,duoshuo:{userId:"0",author:"博主"},algolia:{applicationID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}}}</script><link rel="canonical" href="http://blog.rsuitejs.com/2019/02/02/dart/"><title>Dart 简单入门 | HYPERS 前端团队博客</title><script>!function(e,t,n,c,a,r,s,h){e[n]=e[n]||[],e[n].push(r),e[r]=e[r]||function(){return(e[r].q=e[r].q||[]).push(arguments)},(s=t.createElement(c)).src="//t.hypers.com.cn/hwt.js?v=1.6",s.async=1,(h=t.getElementsByTagName(c)[0]).parentNode.insertBefore(s,h)}(window,document,"HyperAnalyticsObject","script",0,"_ha"),_ha("create","4080"),_ha("send","pageview")</script></head><body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans"><div class="container sidebar-position-left page-post-detail"><div class="headband"></div><header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-wrapper"><div class="site-meta"><div class="custom-logo-site-title"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">HYPERS 前端团队博客</span><span class="logo-line-after"><i></i></span></a></div><p class="site-subtitle"></p></div><div class="site-nav-toggle"> <button><span class="btn-bar"></span><span class="btn-bar"></span><span class="btn-bar"></span></button></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i><br> 首页</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i><br> 分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i><br> 归档</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i><br> 标签</a></li></ul></nav></div></header><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><div id="posts" class="posts-expand"><article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article"><link itemprop="mainEntityOfPage" href="http://blog.rsuitejs.com/2019/02/02/dart/"><span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person"><meta itemprop="name" content="Hypers"><meta itemprop="description" content=""><meta itemprop="image" content="/images/hypers_logo.png"></span><span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization"><meta itemprop="name" content="HYPERS 前端团队博客"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">Dart 简单入门</h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-02T10:20:51+00:00">2019-02-02</time></span><div class="post-wordcount"> <span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-file-word-o"></i></span> <span class="post-meta-item-text">字数统计</span> <span title="字数统计">4,467</span></div></div></header><div class="post-body" itemprop="articleBody"> <img src="/2019/02/02/dart/logo.png" title="这个世界到底还需不需要一门新的语言？"><blockquote><ul><li>推荐图书：<a href="https://book.douban.com/subject/27074797/" target="_blank" rel="noopener">Dart编程语言 - 【美】Gilad Bracha</a></li><li>推荐阅读官方文档：<a href="https://www.dartlang.org/guides/language/language-tour" target="_blank" rel="noopener">A Tour of the Dart Language</a></li><li>建议切一个窗口打开<a href="https://dartpad.dartlang.org/" target="_blank" rel="noopener">DartPad</a>边看边码，更能加深印象！</li></ul></blockquote><h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>Dart 其实并不算一门非常新的语言，最早版本发行与 2011 年 10 月，目标是取代 JavaScript 成为下一代 Web 开发语言（很显然他失败了）。截止发稿已经发布了 2.x 版本，与初始版本并无太多改动，保持了兼容性。他没有像同胞哥哥 <a href="https://zh.wikipedia.org/wiki/Go" target="_blank" rel="noopener">Golang</a> 在后端占有一席之地一样在 Web 端有所作为，而是不温不火好几年，直到 <a href="https://zh.wikipedia.org/wiki/Flutter" target="_blank" rel="noopener">Flutter</a> 的出现才有所改善。<br>语言本身来说，他是一门<strong>强类型且面向类编程</strong>的语言，前端朋友如果长期以 JavaScript 为主力语言的话可能会有些许不适应，但是相信在短暂的学习之后就会上手，并喊出“真香”。<br>笔者是实实在在的新手，本文更多也是作为读书笔记，如果有什么不足或纰漏，还望各位不吝赐教，定虚心接受。</p><h1 id="语言设计理念"><a href="#语言设计理念" class="headerlink" title="语言设计理念"></a>语言设计理念</h1><h2 id="万物皆对象"><a href="#万物皆对象" class="headerlink" title="万物皆对象"></a>万物皆对象</h2><p>不同于 JavaScript 和 Java 有对象和基本值，在 Dart 的世界里<strong>任何事物都是对象</strong>，无一例外。这一点可以让我们更好地去操作我们的代码而不用关心拆装箱等问题，在一定程度上简化了构建逻辑，简化了实现任务。</p><h2 id="面向接口编程，而非面向实现"><a href="#面向接口编程，而非面向实现" class="headerlink" title="面向接口编程，而非面向实现"></a>面向接口编程，而非面向实现</h2><p>关注对象的行为而非内部实现时 OOP 的核心原则，在 Dart 中这一原则被更好地强调和实现，具体方式有以下几条：</p><ul><li>在 Dart 中并不存在声明的接口，因为<strong>所有的类都可以被当做接口</strong>，不管其他类是否采用了同样的底层实现（部分 core type 除外）</li><li>Dart 中没有 final 方法，<strong>允许几乎重写所有方法</strong>（部分内置操作符除外）。</li><li>Dart 把对象进行抽象封装，<strong>所有的操作都是通过存取来改变对象状态的</strong>，即在其他语言中习以为常的<strong><code>=</code>赋值和<code>.</code>取值在 Dart 中也只是<code>get()</code>和<code>set()</code>的语法糖</strong>。</li></ul><h2 id="类型时为开发服务"><a href="#类型时为开发服务" class="headerlink" title="类型时为开发服务"></a>类型时为开发服务</h2><p>这点我感觉与 TypeScript 的理念（或是说实现效果）比较相近，毕竟大家觉得强类型语言写起来舒服的原因就是<strong>清晰的接口</strong>和<strong>便捷的 IDE 提示</strong>，往编译层面来说就是为编译器提供更好的预判，从而优化性能。 Dart 在类型方面采用了可选类型(Sound type) ，算是在强弱类型之间找到了一个平衡：</p><ul><li>类型在语法层面时可选的</li><li>类型对运行时的语义没有影响。</li></ul><p>这意味着你也可以把 Dart 当做一门动态类型语言来编写，虽然不推荐，但是还是在一定程度上给了开发者很高的自由度，让其他语言的开发者更快迁移到 Dart 上来。</p><h1 id="字面量"><a href="#字面量" class="headerlink" title="字面量"></a>字面量</h1><blockquote><p>当然别忘了，他们也都还是对象</p></blockquote><ul><li>整数 <em>int</em>： <code>1</code> <code>2</code> <code>3</code></li><li>浮点数 <em>double</em>：（遵循 IEEE754 标准的 64-bit 浮点数）<code>1.0</code><blockquote><p>在 Dart 2.1 之后 <code>double value = 1;</code> 将自动转为（等价于） <code>double value = 1.0;</code></p></blockquote></li><li>数字 <em>num</em>： 作为<em>int</em>和<em>double</em>的父级</li><li>布尔 <em>bool</em>： <code>true</code></li><li><p>字符串 <em>String</em>： （转义字符用法与 JavaScript 相似）</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> main()&#123;</span><br><span class="line">  <span class="keyword">var</span> man = <span class="string">'Mick'</span>;</span><br><span class="line">  <span class="keyword">var</span> s1 = <span class="string">'It\'s hot today!'</span>;</span><br><span class="line">  <span class="keyword">var</span> s2 = <span class="string">"It's hot today!"</span>;</span><br><span class="line">  <span class="keyword">var</span> s3 = <span class="string">"'It\'s hot today!'<span class="subst">$man</span> said."</span>;</span><br><span class="line">  <span class="keyword">var</span> s4 = <span class="string">'''</span></span><br><span class="line"><span class="string">  It!</span></span><br><span class="line"><span class="string">  is!</span></span><br><span class="line"><span class="string">  hot!</span></span><br><span class="line"><span class="string">  today!</span></span><br><span class="line"><span class="string">  '''</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//You can create a “raw” string by prefixing it with r:</span></span><br><span class="line">  <span class="keyword">var</span> s = <span class="string">r'In a raw string, not even \n gets special treatment.'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>列表 <em>List</em>： <code>[1,2,3]</code></p></li><li>映射 <em>Map</em>： <code>{&#39;1&#39;:1,&#39;2&#39;:2}</code><blockquote><p>注意：虽然和JavaScript中的对象很像但是不能通过<code>.something</code>的方式代替<code>[&#39;sonething&#39;]</code></p></blockquote></li><li>函数 <em>Function</em>： <code>()=&gt;{}</code></li><li>Symbol： (使用 <code>#</code> 开头，后面跟着一个或多个<code>.</code>分割的标识符或运算符，基本用不到) <code>#MyClass</code> <code>#com.evil_empire.forTheWin</code></li></ul><h1 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h1><p>和其他 C-style 语法相似，你之前学到的知识大概率是能用得上的。如果你写过 Java / Kotlin 的话应该会感觉更加亲切，因为真的很像。</p><h2 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h2><p>变量声明方面其实没有声明特别的地方，你可以<del>凭自己的喜好</del>给变量增加类型：<br></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a=<span class="string">'1'</span>;<span class="comment">//不带类型的变量声明</span></span><br><span class="line"><span class="built_in">String</span> b =<span class="string">'1'</span>;<span class="comment">//带类型的变量声明</span></span><br><span class="line"><span class="keyword">const</span> c=<span class="string">'1'</span>;<span class="comment">//常量声明</span></span><br><span class="line"><span class="keyword">final</span> d=<span class="string">'1'</span>;<span class="comment">//在调用后被初始化</span></span><br><span class="line"><span class="keyword">var</span> e;<span class="comment">//未初始化的变量将被初始化为null</span></span><br></pre></td></tr></table></figure><p></p><h2 id="来写一个类吧"><a href="#来写一个类吧" class="headerlink" title="来写一个类吧"></a>来写一个类吧</h2><ul><li><p>你可以像这样写一个类</p><blockquote><p>注意： Dart 是<strong>不支持函数重载</strong>的</p></blockquote><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span></span>&#123;</span><br><span class="line">  <span class="keyword">var</span> x, y;</span><br><span class="line">  Point(a,b)&#123;</span><br><span class="line">    x = a;</span><br><span class="line">    y = b;</span><br><span class="line">  &#125;</span><br><span class="line">  scale(factor)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Point(x * factor, y * factor);<span class="comment">//在 Dart2 中你可以无条件省略 new 关键词</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>你还可以像 Java / C++ 一样写个类</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span></span>&#123;</span><br><span class="line">  <span class="built_in">int</span> x, y;</span><br><span class="line">  Point(a,b)&#123;</span><br><span class="line">    <span class="keyword">this</span>.x = a;</span><br><span class="line">    <span class="keyword">this</span>.y = b;</span><br><span class="line">  &#125;</span><br><span class="line">  scale(factor)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Point(x * factor, y * factor);<span class="comment">//在 Dart2 中你可以无条件省略 new 关键词</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>当然， Dart 也有自己的语法糖</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span></span>&#123;</span><br><span class="line">  <span class="keyword">var</span> x, y;</span><br><span class="line">  Point(<span class="keyword">this</span>.x,<span class="keyword">this</span>.y);<span class="comment">//第一个参数将会自动赋给 x ，第二个参数会自动赋给y</span></span><br><span class="line">  scale(factor) =&gt;  <span class="keyword">new</span> Point(x * factor, y * factor);<span class="comment">//在 Dart2 中你可以无条件省略 new 关键词</span></span><br><span class="line">  <span class="keyword">operator</span> +(p) =&gt; <span class="keyword">new</span> Poinit(x + p.x,y + p.y);<span class="comment">//就像在 c++ 里一样，你又可以重写运算符了！</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在 Dart 中还支持了 <code>staic</code> / <code>final</code> / <code>const</code> 关键词，还有 <code>const构造方法</code></p><blockquote><p>还有抽象关键词<code>abstract</code>，与 Java 用法相似，在此就不做举例。</p></blockquote><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span></span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">var</span> onlyOne = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> neverChange = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">final</span> lazyLoad;<span class="comment">//推荐大部分变量都设置为 final ，可以在声明时初始化，也可以在构造函数初始化（必须二选一）。</span></span><br><span class="line">  <span class="keyword">get</span> onlyOne()&#123;&#125;</span><br><span class="line">  <span class="keyword">set</span> onlyOne()&#123;&#125;</span><br><span class="line">  Foo(lazyOne):lazyLoad=lazyOne,<span class="keyword">super</span>(key:lazyOne);<span class="comment">// final 值也可以通过构造函数后冒号初始化，调用父类构造函数 super。</span></span><br><span class="line">  <span class="keyword">const</span> Foo()<span class="comment">//所有 const 关键词赋值中调用的只能是常量或字面量，因为所有被 const 修饰的方法/变量将会在编译阶段被求值。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Dart 的类支持了 <code>extends</code> / <code>with</code> / <code>implements</code>，按需取用。</p><blockquote><ul><li>和其他现代语言一样， Dart 支持单继承多接口，在此基础上还增加了饱受争议的 mixin （一对多）。</li><li><code>mixin</code> 关键词也可以替代 <code>class</code> 作为声明关键词来使用，以专门编写用于 mixin 的类，如果此 mixin 要求对象实现接口则使用 <code>on</code> 关键词在最后修饰。</li><li>可参考<a href="https://juejin.im/post/5c4881dae51d45098e4d96cf" target="_blank" rel="noopener">Flutter Dart语法(1):extends 、 implements 、 with的用法与区别</a></li></ul></blockquote><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">  m(p, q) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mixin Bar2 on Bar &#123;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * on修饰符要求mixin对象的父类实现了Bar接口</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> m(q, p) &#123;</span><br><span class="line">    <span class="keyword">super</span>.m(q, p);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo1</span> <span class="keyword">extends</span> <span class="title">Bar</span> </span>&#123;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 1. Dart中的继承是单继承</span></span><br><span class="line"><span class="comment">    * 2. 构造函数不能继承</span></span><br><span class="line"><span class="comment">    * 3. 子类重写超类的方法，要用@override</span></span><br><span class="line"><span class="comment">    * 4. 子类调用超类的方法，要用super</span></span><br><span class="line"><span class="comment">    * 注意：不可以重写父类中声明变量的set和get方法（隐式），同时重写的方法要与父类中方法参数个数相同。</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line">  <span class="comment">//...other codes</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo2</span> <span class="keyword">implements</span> <span class="title">Bar</span> </span>&#123;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 1. class 就是 interface</span></span><br><span class="line"><span class="comment">    * 2. 当class被当做interface用时，class中的方法就是接口的方法，需要在子类里重新实现，在子类实现的时候要加@override</span></span><br><span class="line"><span class="comment">    * 3. 当class被当做interface用时，class中的成员变量也需要在子类里重新实现。在成员变量前加@override</span></span><br><span class="line"><span class="comment">    * 4. 实现接口可以有多个</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  m(p, q) &#123;&#125;</span><br><span class="line">  <span class="comment">//...other codes</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo3</span> <span class="title">with</span> <span class="title">Bar</span> </span>&#123;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 1. mixins类只能继承自object</span></span><br><span class="line"><span class="comment">    * 2. mixins类不能有构造函数</span></span><br><span class="line"><span class="comment">    * 3. 一个类可以mixins多个mixins类</span></span><br><span class="line"><span class="comment">    * 4. 可以mixins多个类，不破坏Dart的单继承</span></span><br><span class="line"><span class="comment">    * 注意：mixin有点像extends，但是我理解上更像是原型链的模型，with后即链上对象，采取的是覆盖原则，即靠后的生效。（甚至可以粗暴地理解为复制代码）</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line">  <span class="comment">//...other codes</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo4</span> <span class="keyword">extends</span> <span class="title">Bar</span> <span class="title">with</span> <span class="title">Bar2</span> </span>&#123;</span><br><span class="line">  <span class="comment">//通过继承的方式实现。</span></span><br><span class="line">  <span class="comment">//...other codes</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo5</span> <span class="keyword">extends</span> <span class="title">Foo2</span> <span class="title">with</span> <span class="title">Bar2</span> </span>&#123;</span><br><span class="line">  <span class="comment">//通过继承的方式实现。</span></span><br><span class="line">  <span class="comment">//...other codes</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><ul><li><p>基本的函数可以参考下面，包含了<em>三目运算符</em>和<em>错误抛出</em>。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">maxElement(a)&#123;</span><br><span class="line">  <span class="comment">//你可以在maxElement前面加上返回类型 如 int maxElement(a)</span></span><br><span class="line">  <span class="comment">//你也可以在a前面标注上类型来声明a的类型  如 maxElement(List&lt;int&gt; a)</span></span><br><span class="line">  <span class="keyword">var</span> currentMax = a.isEmpty</span><br><span class="line">    ? <span class="keyword">throw</span> <span class="string">'Maximal element undefined for empty array'</span> : a[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; a.length; i++)&#123;</span><br><span class="line">    currentMax = max(a[i],currentMax);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> currentMax;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Dart还支持了<code>可选参数</code>/<code>具名参数</code>/<code>参数默认值</code>，当然你也可以使用<code>@required</code>来标注具名参数中必须传入的值。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> foo1(a, [ b = <span class="number">1</span>] )&#123;<span class="comment">//a为参数，b为可选参数并设置了默认值1</span></span><br><span class="line">  <span class="built_in">print</span>(<span class="string">'<span class="subst">$&#123;a&#125;</span>,<span class="subst">$&#123;b&#125;</span>'</span>);<span class="comment">//当仅有变量时也可以简写为print('$a,$b')</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> foo2(a,&#123; <span class="meta">@required</span> b, c = <span class="number">0</span> &#125;)&#123;<span class="comment">//a为参数，b/c为具名参数,b为必传，c设置了默认值0</span></span><br><span class="line">  <span class="built_in">print</span>(<span class="string">'<span class="subst">$&#123;a&#125;</span>,<span class="subst">$&#123;b&#125;</span>,<span class="subst">$&#123;c&#125;</span>'</span>);  </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  foo1(<span class="number">1</span>, <span class="number">2</span>);<span class="comment">//1,2</span></span><br><span class="line">  foo2(<span class="number">1</span>, b:<span class="number">2</span>);<span class="comment">//1,2,0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>支持函数作为参数传递，当然也就支持箭头函数，不同于 JavaScript 中的箭头函数和普通函数有 this 的区别， <strong>Dart 中的箭头函数就是实实在在的“糖”</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> main()=&gt;&#123;&#125;;</span><br></pre></td></tr></table></figure></li><li><p>Dart同样支持了闭包，但是和JavaScript的又不大一样，这里有个不得不吐的槽：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);<span class="comment">//他会很不合预期地打出五个5</span></span><br><span class="line">  &#125;, <span class="number">1000</span> * i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码应该是前端面试的常客了，但是与它类似的代码在 Dart 中就显得很“正常”</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'dart:async'</span>;</span><br><span class="line"><span class="keyword">void</span> main()&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">    Timer(<span class="built_in">Duration</span>(seconds: i), () &#123;</span><br><span class="line">      <span class="built_in">print</span>(i);<span class="comment">//0,1,2,3,4</span></span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为在 Dart 中，每次执行 for 都会给代码新建一个 <em>context</em> ，所以在<strong>每次执行的 Timer 都是一个全新的 <code>i</code></strong></p></li><li><p>在函数的调用上页支持<code>..</code>来级联操作，它不像<code>.</code>会返回调用后的结果，而是返回被调用者本身，这样的设计给链式调用多了一种选择。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> main()&#123;</span><br><span class="line">  <span class="comment">/*1*/</span><span class="string">"Hello"</span>.length.toString();<span class="comment">//5</span></span><br><span class="line">  <span class="comment">/*2*/</span><span class="string">"Hello"</span>..length.toString();<span class="comment">//Hello</span></span><br><span class="line">  <span class="comment">/*第2行等价于*/</span></span><br><span class="line">  <span class="string">"Hello"</span>.length;</span><br><span class="line">  <span class="string">"Hello"</span>.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>如果函数调用<code>()</code>也是”糖”？没错。他就是<code>.call()</code>方法的语法糖。所以你可以给对象加上<code>call</code>方法以使用<code>()</code>来调用方法。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">fakeFunc</span> </span>&#123;</span><br><span class="line">  call() &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'works!'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="keyword">var</span> a = fakeFunc();</span><br><span class="line">  a();<span class="comment">//works!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Dart同样支持迭代器语法，支持同步和异步</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">naturalsTo(n) <span class="keyword">sync</span>* &#123;<span class="comment">//同步迭代器</span></span><br><span class="line">  <span class="keyword">var</span> k=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(k&lt;n) <span class="keyword">yield</span> k++;</span><br><span class="line">&#125;</span><br><span class="line">naturalsTo(n) <span class="keyword">async</span>* &#123;<span class="comment">//异步迭代器</span></span><br><span class="line">  <span class="keyword">var</span> k=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(k&lt;n) <span class="keyword">yield</span> <span class="keyword">await</span> k++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>还有一个不得不提的方法 <code>noSuchMethod</code> ，如果运行时对象没有对应的方法，将会调用这个方法，这使得我们可以由此做一些”Hack“(关于反射和动态代码)<br>对于 <code>noSuchMethod()</code> 的参数只有一个 <code>Invocation</code> 。关于 <code>Invocation</code> 的布尔属性所辨认的方法调用的句法形式，如下表所示：</p></li></ul><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">x.y</th><th style="text-align:center">x.y = e</th><th style="text-align:center">x.y(…)</th></tr></thead><tbody><tr><td style="text-align:center">isMethod</td><td style="text-align:center">false</td><td style="text-align:center">false</td><td style="text-align:center">true</td></tr><tr><td style="text-align:center">isGetter</td><td style="text-align:center">true</td><td style="text-align:center">false</td><td style="text-align:center">false</td></tr><tr><td style="text-align:center">isSetter</td><td style="text-align:center">false</td><td style="text-align:center">true</td><td style="text-align:center">false</td></tr><tr><td style="text-align:center">isAccessor</td><td style="text-align:center">true</td><td style="text-align:center">true</td><td style="text-align:center">false</td></tr></tbody></table><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  noSuchMethod(Invocation inv)=&gt;<span class="built_in">print</span>(<span class="string">'fallback!'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> main()&#123;</span><br><span class="line">  <span class="keyword">var</span> a = A();</span><br><span class="line">  <span class="comment">//注：更多时候你将会被 IDE 拦下来</span></span><br><span class="line">  a.x();<span class="comment">//'fallback!'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="其他语句"><a href="#其他语句" class="headerlink" title="其他语句"></a>其他语句</h2><ul><li>支持 c-style 的 <code>if(){}else if(){}else{}</code></li><li>支持以<code>{}</code>分界的块状作用域，不允许块之间互相递归声明。</li><li>支持 c-style 的 <code>for</code> / <code>while</code> / <code>do-while</code> 循环以及相对应的 <code>continue</code> / <code>break</code>（还有对应的 label 也是支持的），还支持了 <code>for-in</code> 语法来快捷遍历集合类</li><li>支持 <code>switch-case</code> 多条件选择<blockquote><p>注意：case 的值仅能为常量，且不允许<a href="https://en.wikipedia.org/wiki/Switch_statement#Fallthrough" target="_blank" rel="noopener">falls-through</a>，必须使用 break 跳出。</p></blockquote></li><li>支持 <code>assert</code> 语法，优化开发体验。<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> main()&#123;</span><br><span class="line">  <span class="built_in">int</span> x = <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">assert</span>(x&gt;<span class="number">0</span>);<span class="comment">//在开发模式下报错</span></span><br><span class="line">  x++;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><p> Dart 支持最舒适的 <code>throw</code> + <code>try{}catch(){}finally{}</code>语法，不多说！</p><h1 id="库-模块"><a href="#库-模块" class="headerlink" title="库/模块"></a>库/模块</h1><ul><li>Dart 的模块化比较像 C / C++ / Java ，他是将 import 的文件直接注入到<strong>当前文件全局作用域</strong>下的。</li><li><p>Dart 引入关键词为 <code>import</code> ，支持使用 <code>as</code> 来重命名，还有 <code>deferred as</code> 来延迟加载，也支持使用 <code>show</code> / <code>hide</code> 组合器来限定引入范围。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'stack.dart'</span> show pop,push;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'advancedStack.dart'</span> <span class="keyword">as</span> stack2 hide pop,push;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'mayUseless.dart'</span> deferred <span class="keyword">as</span> rarelyUsed;<span class="comment">//只有在使用时才会被加载</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main()&#123;</span><br><span class="line">  onLoad(loadSuccess)=&gt;loadSuceess?doStuff():makeExcusses();</span><br><span class="line">  rarelyUsed.loadLibrary().then(onLoad);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>export</code> 用于中转某个库需要在当前文件暴露的方法，但并不是和 import 配套使用的。同样支持使用 <code>show</code> / <code>hide</code> 组合器来限定引入范围。</p><blockquote><p>类似于 JavaScript(ES6) 里的 <code>export from</code> 语法</p></blockquote><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="string">'stack.dart'</span> hide pop;</span><br></pre></td></tr></table></figure></li><li><p>还有一个对我而言比较陌生的关键词： <code>part</code> ，有的时候一个库可能太大，不能方便的保存在一个文件当中。Dart 允许我们把一个库拆分成一个或者多个较小的 part 组件。或者我们想让某一些库共享它们的私有对象的时候，我们需要使用 part。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A.dart</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'stack.dart'</span> show pop;</span><br><span class="line"><span class="keyword">part</span> <span class="string">'A_1.dart'</span>;</span><br></pre></td></tr></table></figure><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//A_1.dart</span></span><br><span class="line"><span class="keyword">part</span> of <span class="string">'A.dart'</span>;</span><br><span class="line"><span class="keyword">void</span> main()&#123;</span><br><span class="line">  pop(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们可以看到，<code>A_1.dart</code>是<code>part of &#39;A.dart&#39;</code>的文件，可以理解为，<code>A_1</code>是<code>A</code>的一部分。在<code>part test2.dart</code>中，我们并没有引入<code>stack.dart</code>包就直接使用了<code>pop</code>方法，是因为，在 part 中， import 进来的库是共享命名空间的。<br>不是所有的库都有名称，但如果使用 part 来构建库，那么库必须要命名。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">library</span> xxx;</span><br></pre></td></tr></table></figure><p>每个子 part 都存放在各自的文件中。但是它们共享同一作用域，库的内部命名空间，以及所有的导入（import）。</p></li></ul><h1 id="可选类型-泛型"><a href="#可选类型-泛型" class="headerlink" title="可选类型/泛型"></a>可选类型/泛型</h1><p>正如之前提到的，Dart 中的类型是可选的，它仅为开发提供便利，同时也提供了泛型来约束集合内的类型，用法与 C++ / Java 类似。<br></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">List</span>&lt;<span class="built_in">num</span>&gt; list;</span><br><span class="line"><span class="built_in">Map</span>&lt;<span class="built_in">String</span>,<span class="built_in">int</span>&gt; map;</span><br><span class="line"><span class="built_in">Map</span>&lt;<span class="built_in">String</span>,<span class="keyword">dynamic</span>&gt; map2;</span><br><span class="line"><span class="built_in">Map</span>&lt;<span class="keyword">dynamic</span>,<span class="keyword">dynamic</span>&gt; freeMap;<span class="comment">//等价于 Map freeMap;</span></span><br></pre></td></tr></table></figure><p></p><p>你可以使用 <code>is</code> 关键字来检测是否为某个类的实例<br></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> main()&#123; </span><br><span class="line">  <span class="keyword">var</span> v=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line">  v <span class="keyword">is</span> <span class="built_in">Map</span>;<span class="comment">//false</span></span><br><span class="line">  v <span class="keyword">is</span> <span class="built_in">List</span>;<span class="comment">//true </span></span><br><span class="line">  v <span class="keyword">is</span> <span class="built_in">Object</span>;<span class="comment">//always true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>还可以使用 <code>as</code> 进行强制类型转换,这部分与 Java 的强制类型转换相似，只能是从子类转化为父类。<br></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> main()&#123;</span><br><span class="line">  <span class="number">1</span> <span class="keyword">as</span> <span class="built_in">Object</span>;<span class="comment">//无意义的转换，仅作举例</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h1 id="注解（Annotation）"><a href="#注解（Annotation）" class="headerlink" title="注解（Annotation）"></a>注解（Annotation）</h1><blockquote><p>对于 Java 程序员来说<a href="https://blog.csdn.net/briblue/article/details/73824058" target="_blank" rel="noopener">注解</a>一定不陌生，对于 JavaScript 程序员来说，可能听说过<a href="http://es6.ruanyifeng.com/#docs/decorator" target="_blank" rel="noopener">装饰器(decorator)</a>的提案。</p></blockquote><p>注解作为<a href="https://www.dartlang.org/guides/language/language-tour#metadata" target="_blank" rel="noopener">元数据(metadata)</a>，是为了给代码提供额外的信息，提升编码体验，大部分时候并不会对代码产生实质性影响。它以<code>@</code>打头，后跟一个<code>const常量</code>或调用一个<code>const构造函数</code>，内置对象有 <code>@required</code> <code>@deprecated</code> 等。<br></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Television</span> </span>&#123;</span><br><span class="line">  <span class="comment">/// _Deprecated: Use [turnOn] instead._</span></span><br><span class="line">  <span class="meta">@deprecated</span></span><br><span class="line">  <span class="keyword">void</span> activate() &#123;</span><br><span class="line">    turnOn();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// Turns the TV's power on.</span></span><br><span class="line">  <span class="keyword">void</span> turnOn() &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>你也可以自定义一个注解：<br></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Todo</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">String</span> who;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">String</span> what;</span><br><span class="line">  <span class="keyword">const</span> Todo(<span class="keyword">this</span>.who, <span class="keyword">this</span>.what);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Todo</span>(<span class="string">'seth'</span>, <span class="string">'make this do something'</span>)<span class="comment">//使用自定义注解</span></span><br><span class="line"><span class="keyword">void</span> doSomething() &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">'do something'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h1 id="Async"><a href="#Async" class="headerlink" title="Async"></a>Async</h1><p>让我很喜欢 JavaScript 的原因之一就是在疏不在堵的异步调用（在 Node 上更为明显），这也是很多 JavaScript 新手的末日。<br>很高兴在 Dart 上能找到几乎一样的实现方案: <code>Future</code><br></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'dart:async'</span>;</span><br><span class="line"><span class="comment">//定义了返回结果值为String类型</span></span><br><span class="line">Future&lt;<span class="built_in">String</span>&gt; getData(<span class="built_in">String</span> category) <span class="keyword">async</span> &#123;</span><br><span class="line">  <span class="keyword">var</span> request = <span class="keyword">await</span> _httpClient.getUrl(<span class="built_in">Uri</span>.parse(url));  </span><br><span class="line">  <span class="keyword">var</span> response = <span class="keyword">await</span> request.close();</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">await</span> response.transform(utf8.decoder).join();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() <span class="keyword">async</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> data = <span class="keyword">await</span> getData(<span class="string">'test'</span>);<span class="comment">//调用 async 函数</span></span><br><span class="line">  <span class="comment">//链式调用，捕获异常</span></span><br><span class="line">  <span class="keyword">var</span> future = <span class="comment">//调式调用</span></span><br><span class="line">    <span class="keyword">new</span> Future</span><br><span class="line">    .then(funA(),onError: (e) &#123; handleError(e); &#125;)</span><br><span class="line">    .then(funB(),onError: (e) &#123; handleError(e); &#125;);    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>与 ES6 中的 <code>Promise</code> 用法基本一致，具名参数的加成使得代码可读性更佳，真香！</p><h1 id="一些有趣的特性"><a href="#一些有趣的特性" class="headerlink" title="一些有趣的特性"></a>一些有趣的特性</h1><ul><li>在 Dart 程序中一定存在一个入口函数，和 C 一样，我们把他命名为 main ()，虽然是在面向类编程，但是我们依然可以<strong>在文件的最外层可以直接声明函数和变量</strong>，这点和 Java 倒是不大一样，但其实幕后工作编译器都帮我们做好了，我们只管写就好了!</li><li>Dart 中的整数长度取决于你的内存大小（编译成目标语言除外<del>。说你呢 JavaScript ！</del>）</li><li><code>final</code> 声明的值将是采用<strong>懒加载的方式</strong>，即<strong>只有当<code>get()</code>被调用之前，该变量才会被初始化</strong>。</li><li>在 Dart 中<strong>只有 <code>bool</code> 类型的 <code>true</code> 是 <code>true</code> ,其他对象都是 <code>false</code></strong> ，<del>虽然不影响编译，</del>但是在你写出来的时候 IDE 就会拼命给你报错了。</li><li>Dart <strong>不存在内部类</strong>，类中<strong>不存在私有方法</strong>所有的方法都是可见并大部分都是可以重写的。私有变量以<code>_</code>开头，如 <code>_privateThing</code>;</li></ul><h1 id="一些高级特性"><a href="#一些高级特性" class="headerlink" title="一些高级特性"></a>一些高级特性</h1><blockquote><p>由于本文为入门教程，笔者对于 Dart 也是入门不久，以下高级编程部分用的较少，作为补充仅提及，后续可能会更新补充，有兴趣的读者可以自行搜索学习。</p></blockquote><ul><li>代理 (Proxy)</li><li>反射 (Mirror)</li></ul></div><div></div><div></div><div><hr><ul class="post-copyright"><li class="post-copyright-author"> <strong>本文作者：</strong> <a href="https://github.com/Sleaf">Sleaf</a></li><li class="post-copyright-link"> <strong>本文链接：</strong> <a href="http://blog.rsuitejs.com/2019/02/02/dart/" title="Dart 简单入门">http://blog.rsuitejs.com/2019/02/02/dart/</a></li><li class="post-copyright-license"> <strong>版权声明：</strong> 本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/3.0/" rel="external nofollow" target="_blank">CC BY-NC-SA 3.0</a> 许可协议。转载请注明出处！</li></ul></div><footer class="post-footer"><div class="post-tags"><a href="/tags/Dart/" rel="tag"><i class="fa fa-tag"></i> Dart</a></div><div class="post-nav"><div class="post-nav-next post-nav-item"><a href="/2018/12/12/webpack-optimize/" rel="next" title="Webpack性能优化整理"><i class="fa fa-chevron-left"></i> Webpack性能优化整理</a></div><span class="post-nav-divider"></span><div class="post-nav-prev post-nav-item"></div></div></footer></article><div class="post-spread"></div></div></div><div class="comments" id="comments"><div id="gitment"></div></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span><span class="sidebar-toggle-line sidebar-toggle-line-middle"></span><span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap"> 文章目录</li><li class="sidebar-nav-overview" data-target="site-overview"> 站点概览</li></ul><section class="site-overview sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person"> <img class="site-author-image" itemprop="image" src="/images/hypers_logo.png" alt="Hypers"><p class="site-author-name" itemprop="name">Hypers</p><p class="site-description motion-element" itemprop="description"></p></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"> <a href="/archives/"><span class="site-state-item-count">24</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"> <a href="/categories/index.html"><span class="site-state-item-count">2</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"> <a href="/tags/index.html"><span class="site-state-item-count">45</span> <span class="site-state-item-name">标签</span></a></div></nav><div class="links-of-author motion-element"></div></section><section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active"><div class="post-toc"><div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#写在前面"><span class="nav-number">1.</span> <span class="nav-text">写在前面</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#语言设计理念"><span class="nav-number">2.</span> <span class="nav-text">语言设计理念</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#万物皆对象"><span class="nav-number">2.1.</span> <span class="nav-text">万物皆对象</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#面向接口编程，而非面向实现"><span class="nav-number">2.2.</span> <span class="nav-text">面向接口编程，而非面向实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#类型时为开发服务"><span class="nav-number">2.3.</span> <span class="nav-text">类型时为开发服务</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#字面量"><span class="nav-number">3.</span> <span class="nav-text">字面量</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#基本语法"><span class="nav-number">4.</span> <span class="nav-text">基本语法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#变量声明"><span class="nav-number">4.1.</span> <span class="nav-text">变量声明</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#来写一个类吧"><span class="nav-number">4.2.</span> <span class="nav-text">来写一个类吧</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#函数"><span class="nav-number">4.3.</span> <span class="nav-text">函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#其他语句"><span class="nav-number">4.4.</span> <span class="nav-text">其他语句</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#异常处理"><span class="nav-number">4.5.</span> <span class="nav-text">异常处理</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#库-模块"><span class="nav-number">5.</span> <span class="nav-text">库/模块</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#可选类型-泛型"><span class="nav-number">6.</span> <span class="nav-text">可选类型/泛型</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#注解（Annotation）"><span class="nav-number">7.</span> <span class="nav-text">注解（Annotation）</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Async"><span class="nav-number">8.</span> <span class="nav-text">Async</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#一些有趣的特性"><span class="nav-number">9.</span> <span class="nav-text">一些有趣的特性</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#一些高级特性"><span class="nav-number">10.</span> <span class="nav-text">一些高级特性</span></a></li></ol></div></div></section></div></aside></div></main><footer id="footer" class="footer"><div class="footer-inner"><div class="copyright"> &copy; <span itemprop="copyrightYear">2019</span><span class="with-love"><i class="fa fa-heart"></i></span> <span class="author" itemprop="copyrightHolder">Hypers</span> <span class="post-count">- 全站共56.0k字</span></div><div class="powered-by"> 由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动</div><div class="theme-info"> 主题 - <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a></div></div></footer><div class="back-to-top"><i class="fa fa-arrow-up"></i></div></div><script type="text/javascript">"[object Function]"!==Object.prototype.toString.call(window.Promise)&&(window.Promise=null)</script><script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script><script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script><script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script><script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script><script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script><script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script><script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.1"></script><script type="text/javascript" src="/js/src/post-details.js?v=5.1.1"></script><script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script></body></html>