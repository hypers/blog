<!DOCTYPE html><html class="theme-next muse use-motion" lang="zh-Hans"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><script src="/lib/pace/pace.min.js?v=1.0.2"></script><link href="/lib/pace/pace-theme-minimal.min.css?v=1.0.2" rel="stylesheet"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"><link href="//fonts.loli.net/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css"><link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css"><link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css"><meta name="keywords" content="ECMAScript 2016,ECMAScript 2017,ECMAScript 2018,"><link rel="shortcut icon" type="image/x-icon" href="/favicon.png?v=5.1.1"><meta name="description" content="以下是 ECMAScript 2016, 2017, 和 2018 中新增功能的示例原文链接 要跟上 JavaScript(ECMAScript) 更新的脚步很难，更难的是找到有用的代码示例。 因此，在本文中，我将介绍在 ES2016，ES2017 和 ES2018（最终草案）中添加的TC39已完成提案中列出的所有 18 个新特性，并一一展示有用的示例。  这篇文章很长，不过应该很容易读，可以当成"><meta name="keywords" content="ECMAScript 2016,ECMAScript 2017,ECMAScript 2018"><meta property="og:type" content="article"><meta property="og:title" content="ECMAScript 2016, 2017, 和2018中新增功能的示例"><meta property="og:url" content="http://blog.rsuitejs.com/2018/04/11/es2016-17-18/index.html"><meta property="og:site_name" content="HYPERS 前端团队博客"><meta property="og:description" content="以下是 ECMAScript 2016, 2017, 和 2018 中新增功能的示例原文链接 要跟上 JavaScript(ECMAScript) 更新的脚步很难，更难的是找到有用的代码示例。 因此，在本文中，我将介绍在 ES2016，ES2017 和 ES2018（最终草案）中添加的TC39已完成提案中列出的所有 18 个新特性，并一一展示有用的示例。  这篇文章很长，不过应该很容易读，可以当成"><meta property="og:locale" content="zh-Hans"><meta property="og:updated_time" content="2019-02-14T04:30:39.232Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="ECMAScript 2016, 2017, 和2018中新增功能的示例"><meta name="twitter:description" content="以下是 ECMAScript 2016, 2017, 和 2018 中新增功能的示例原文链接 要跟上 JavaScript(ECMAScript) 更新的脚步很难，更难的是找到有用的代码示例。 因此，在本文中，我将介绍在 ES2016，ES2017 和 ES2018（最终草案）中添加的TC39已完成提案中列出的所有 18 个新特性，并一一展示有用的示例。  这篇文章很长，不过应该很容易读，可以当成"><script type="text/javascript" id="hexo.configurations">var NexT=window.NexT||{},CONFIG={root:"/",scheme:"Muse",sidebar:{position:"left",display:"post",offset:12,offset_float:0,b2t:!1,scrollpercent:!1,onmobile:!1},fancybox:!0,motion:!0,duoshuo:{userId:"0",author:"博主"},algolia:{applicationID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}}}</script><link rel="canonical" href="http://blog.rsuitejs.com/2018/04/11/es2016-17-18/"><title>ECMAScript 2016, 2017, 和2018中新增功能的示例 | HYPERS 前端团队博客</title><script>!function(e,t,n,c,a,r,s,h){e[n]=e[n]||[],e[n].push(r),e[r]=e[r]||function(){return(e[r].q=e[r].q||[]).push(arguments)},(s=t.createElement(c)).src="//t.hypers.com.cn/hwt.js?v=1.6",s.async=1,(h=t.getElementsByTagName(c)[0]).parentNode.insertBefore(s,h)}(window,document,"HyperAnalyticsObject","script",0,"_ha"),_ha("create","4080"),_ha("send","pageview")</script></head><body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans"><div class="container sidebar-position-left page-post-detail"><div class="headband"></div><header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-wrapper"><div class="site-meta"><div class="custom-logo-site-title"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">HYPERS 前端团队博客</span><span class="logo-line-after"><i></i></span></a></div><p class="site-subtitle"></p></div><div class="site-nav-toggle"> <button><span class="btn-bar"></span><span class="btn-bar"></span><span class="btn-bar"></span></button></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i><br> 首页</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i><br> 分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i><br> 归档</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i><br> 标签</a></li></ul></nav></div></header><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><div id="posts" class="posts-expand"><article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article"><link itemprop="mainEntityOfPage" href="http://blog.rsuitejs.com/2018/04/11/es2016-17-18/"><span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person"><meta itemprop="name" content="Hypers"><meta itemprop="description" content=""><meta itemprop="image" content="/images/hypers_logo.png"></span><span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization"><meta itemprop="name" content="HYPERS 前端团队博客"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">ECMAScript 2016, 2017, 和2018中新增功能的示例</h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-11T00:00:00+00:00">2018-04-11</time></span><div class="post-wordcount"> <span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-file-word-o"></i></span> <span class="post-meta-item-text">字数统计</span> <span title="字数统计">6,651</span></div></div></header><div class="post-body" itemprop="articleBody"><h1 id="以下是-ECMAScript-2016-2017-和-2018-中新增功能的示例"><a href="#以下是-ECMAScript-2016-2017-和-2018-中新增功能的示例" class="headerlink" title="以下是 ECMAScript 2016, 2017, 和 2018 中新增功能的示例"></a>以下是 ECMAScript 2016, 2017, 和 2018 中新增功能的示例</h1><p><a href="https://medium.freecodecamp.org/here-are-examples-of-everything-new-in-ecmascript-2016-2017-and-2018-d52fa3b5a70e" target="_blank" rel="noopener">原文链接</a></p><p>要跟上 JavaScript(ECMAScript) 更新的脚步很难，更难的是找到有用的代码示例。</p><p>因此，在本文中，我将介绍在 ES2016，ES2017 和 ES2018（最终草案）中添加的TC39已完成提案中列出的所有 18 个新特性，并一一展示有用的示例。</p><blockquote><p>这篇文章很长，不过应该很容易读，可以当成一篇“Netflix binge reading”。我保证你读完后将对这些新特性有很多的了解。</p></blockquote><p><strong>好，我们一个一个来看看。</strong></p><a id="more"></a><h2 id="ECMAScript-2016"><a href="#ECMAScript-2016" class="headerlink" title="ECMAScript 2016"></a>ECMAScript 2016</h2><ul><li><h3 id="1-Array-prototype-includes"><a href="#1-Array-prototype-includes" class="headerlink" title="1. Array.prototype.includes"></a>1. Array.prototype.includes</h3></li></ul><p><code>includes</code> 是 Array 的一个实例方法，用来轻松查找某个项是否在 Array 中（包括 <code>NaN</code>，这点 <code>indexOf</code> 做不到）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [ <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="literal">NaN</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// es2016不使用</span></span><br><span class="line"><span class="keyword">if</span>(arr.indexOf(<span class="number">3</span>) &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="keyword">if</span>(arr.includes(<span class="number">3</span>))&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//ps: 注意 indexOf 是不支持查找NaN的</span></span><br><span class="line">arr.includes(<span class="literal">NaN</span>) <span class="comment">// true</span></span><br><span class="line">arr.indexOf(<span class="literal">NaN</span>) <span class="comment">// -1 (indexOf 不支持 NaN)</span></span><br></pre></td></tr></table></figure><blockquote><p>冷知识：JavaScript 规范制定者本想给它取名叫 <code>contains</code>，但这显然已被 Mootools 使用，因此他们使用了 <code>includes</code>。</p></blockquote><ul><li><h3 id="2-幂运算符"><a href="#2-幂运算符" class="headerlink" title="2. 幂运算符"></a>2. 幂运算符</h3></li></ul><p>数学运算如加法和减法分别有 <code>+</code> 和 <code>-</code> 等运算符。与他们类似，<code>**</code> 运算符通常用于幂运算。在 ECMAScript 2016 中引入了 <code>**</code>，取代 <code>Math.pow</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不使用</span></span><br><span class="line"><span class="built_in">Math</span>.pow(<span class="number">7</span>,<span class="number">2</span>) <span class="comment">//49</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="number">7</span>**<span class="number">2</span> <span class="comment">//49</span></span><br></pre></td></tr></table></figure><h2 id="ECMAScript-2017"><a href="#ECMAScript-2017" class="headerlink" title="ECMAScript 2017"></a>ECMAScript 2017</h2><ul><li><h3 id="1-Object-values"><a href="#1-Object-values" class="headerlink" title="1. Object.values()"></a>1. Object.values()</h3></li></ul><p><code>Object.value()</code> 是一个新的函数，它与 <code>Object.keys()</code> 类似，但返回的事 Object 所有属性的值（不包括来自原型链的属性）。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> cars = &#123; <span class="string">'BMW'</span>: <span class="number">3</span>, <span class="string">'Tesla'</span>: <span class="number">2</span>, <span class="string">'Toyota'</span>: <span class="number">1</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES2015</span></span><br><span class="line"><span class="comment">// ES2017 不使用</span></span><br><span class="line"><span class="keyword">const</span> vals = <span class="built_in">Object</span>.keys(cars).map(<span class="function"><span class="params">key</span> =&gt;</span> cars[key]);</span><br><span class="line"><span class="built_in">console</span>.log(vals); <span class="comment">//[3, 2, 1]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// ES2017 and 未来</span></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="keyword">const</span> values = <span class="built_in">Object</span>.values(cars);</span><br><span class="line"><span class="built_in">console</span>.log(values); <span class="comment">// [3, 2, 1]</span></span><br></pre></td></tr></table></figure><ul><li><h3 id="2-Object-entries"><a href="#2-Object-entries" class="headerlink" title="2. Object.entries()"></a>2. Object.entries()</h3></li></ul><p><code>Object.entries()</code> 与 <code>Object.keys</code> 相关，但不是仅返回 keys，而是以数组方式返回 keys 和 values。这让你可以很容易地遍历对象，或者把对象转换为 Maps。</p><p>例 1:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> cars = &#123; <span class="string">'BMW'</span>: <span class="number">3</span>, <span class="string">'Tesla'</span>: <span class="number">2</span>, <span class="string">'Toyota'</span>: <span class="number">1</span> &#125;;</span><br><span class="line"><span class="comment">// ES5.1</span></span><br><span class="line"><span class="comment">// 而不是提取键然后再循环</span></span><br><span class="line"><span class="built_in">Object</span>.keys(cars).forEarch(<span class="function"><span class="keyword">function</span>(<span class="params">key</span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">'key: '</span> + key + <span class="string">'value: '</span> + cars[key]);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES2017 (ES8)</span></span><br><span class="line"><span class="comment">// 使用 Object.entries</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> [key value] <span class="keyword">of</span> <span class="built_in">Object</span>.entries(cars)) &#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">`key: <span class="subst">$&#123;key&#125;</span> value: <span class="subst">$&#123;value&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例 2:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> cars = &#123; <span class="string">'BMW'</span>: <span class="number">3</span>, <span class="string">'Tesla'</span>: <span class="number">2</span>, <span class="string">'Toyota'</span>: <span class="number">1</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES2015</span></span><br><span class="line"><span class="comment">// 不使用</span></span><br><span class="line"><span class="comment">// 获取对象键，然后添加每个项目以在循环中映射</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> maps = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"><span class="built_in">Object</span>.keys(cars).forEarch(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">	map1.set(key, cars[key]);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(map1) <span class="comment">// Map &#123; 'BMW' =&gt; 3, 'Tesla' =&gt; 2, 'Toyota' =&gt; 1&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ES2017 and 以后</span></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>(<span class="built_in">Object</span>.entries(cars));</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(map) <span class="comment">//Map &#123; 'BMW' =&gt; 3, 'Tesla' =&gt; 2, 'Toyota' =&gt; 1&#125;</span></span><br></pre></td></tr></table></figure><ul><li><h3 id="3-字符串填充"><a href="#3-字符串填充" class="headerlink" title="3. 字符串填充"></a>3. 字符串填充</h3></li></ul><p>String 增加了两个实例方法 – <code>String.prototype.padStart</code> 和 <code>String.prototype.padEnd</code>，用于在原字符串的开头或结尾添加一段字符串或空字符串。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&apos;someString&apos;.padStart(numberOfCharcters [,stringForPadding]);</span><br><span class="line">&apos;5&apos;.padStart(10) // &apos;          5&apos;</span><br><span class="line">&apos;5&apos;.padStart(10, &apos;=*&apos;) //&apos;=*=*=*=*=5&apos;</span><br><span class="line">&apos;5&apos;.padEnd(10) // &apos;5         &apos;</span><br><span class="line">&apos;5&apos;.padEnd(10, &apos;=*&apos;) //&apos;5=*=*=*=*=&apos;</span><br></pre></td></tr></table></figure><blockquote><p>这在需要对齐事物的场景下很方便，诸如漂亮的打印显示或终端打印。</p></blockquote><ul><li><h4 id="3-1-padStart-例子"><a href="#3-1-padStart-例子" class="headerlink" title="3.1 padStart 例子"></a>3.1 padStart 例子</h4></li></ul><p>在下面的例子中，我们有一组长度不同的数字。为了显示好看，我们希望在它们前面补“0”，让它们长度都达到 10。我们可以使用 <code>padStart(10, &#39;0&#39;)</code> 轻松实现这一点。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ES2017</span></span><br><span class="line"><span class="comment">// 如果你有一个不同长度的项目列表，并希望格式化它们的显示目的，你可以使用padStart</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> formatted = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">12</span>, <span class="number">123</span>, <span class="number">1234</span>, <span class="number">12345</span>].map(<span class="function"><span class="params">num</span> =&gt;</span></span><br><span class="line">	num.toString().padStart(<span class="number">10</span>, <span class="string">'0'</span>) <span class="comment">// 添加 0 直到长度为 10</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(formatted);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印</span></span><br><span class="line"><span class="comment">// [</span></span><br><span class="line"><span class="comment">// 	'0000000000',</span></span><br><span class="line"><span class="comment">// 	'0000000001',</span></span><br><span class="line"><span class="comment">// 	'0000000012',</span></span><br><span class="line"><span class="comment">// 	'0000000123',</span></span><br><span class="line"><span class="comment">// 	'0000001234',</span></span><br><span class="line"><span class="comment">// 	'0000012345',</span></span><br><span class="line"><span class="comment">// ]</span></span><br></pre></td></tr></table></figure><ul><li><h4 id="3-2-padEnd-例子"><a href="#3-2-padEnd-例子" class="headerlink" title="3.2 padEnd 例子:"></a>3.2 padEnd 例子:</h4></li></ul><p>我们打印多个不同长度的项目并想要右对齐它们时，<code>padEnd</code> 真的很方便。</p><p>下面的例子很好地展示了如何运用 <code>padEnd</code>，<code>padStart</code> 和 <code>Object.entries</code> 产生漂亮的输出。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> cars = &#123;</span><br><span class="line">  <span class="string">'🚙BMW'</span>: <span class="string">'10'</span>,</span><br><span class="line">  <span class="string">'🚘Tesla'</span>: <span class="string">'5'</span>,</span><br><span class="line">  <span class="string">'🚖Lamborghini'</span>: <span class="string">'0'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Object</span>.entries(cars).map(<span class="function">(<span class="params">[name, count]</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">//padEnd appends ' -' until the name becomes 20 characters</span></span><br><span class="line">  <span class="comment">//padStart prepends '0' until the count becomes 3 characters.</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;name.padEnd(<span class="number">20</span>, <span class="string">' -'</span>)&#125;</span> Count: <span class="subst">$&#123;count.padStart(<span class="number">3</span>, <span class="string">'0'</span>)&#125;</span>`</span>)</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 打印结果..</span></span><br><span class="line"><span class="comment">// 🚙BMW - - - - - - -  Count: 010</span></span><br><span class="line"><span class="comment">// 🚘Tesla - - - - - -  Count: 005</span></span><br><span class="line"><span class="comment">// 🚖Lamborghini - - -  Count: 000</span></span><br></pre></td></tr></table></figure><ul><li><h4 id="3-3-⚠️-Emoji-和其他双字节字符上的-padStart-和-padEnd"><a href="#3-3-⚠️-Emoji-和其他双字节字符上的-padStart-和-padEnd" class="headerlink" title="3.3 ⚠️ Emoji 和其他双字节字符上的 padStart 和 padEnd"></a>3.3 ⚠️ Emoji 和其他双字节字符上的 padStart 和 padEnd</h4></li></ul><p>Emoji 和其他双字节字符使用多个 unicode 字节表示。所以 <code>padStart</code> 和 <code>padEnd</code> 可能无法按预期工作！⚠️</p><p>例如：假设我们正在尝试用 ❤ ️表情符号填充字符串 <code>heart</code> 以达到10个字符。结果如下所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意，不是5颗心，只有2颗心和1颗看起来很奇怪的心！</span></span><br><span class="line"></span><br><span class="line"><span class="string">'heart'</span>.padStart(<span class="number">10</span>, <span class="string">"❤️"</span>); <span class="comment">// prints.. '❤️❤️❤heart'</span></span><br></pre></td></tr></table></figure><p>这是因为 ❤ ️长 2 个字符(<code>&#39;\u2764\uFE0F&#39;</code>)！单词 heart 本身是 5 个字符，我们要填充剩下的 5 个字符。所以 JS 先填充了两个 <code>&#39;\u2764\uFE0F&#39;</code> （也就是 ❤️❤️️） ️，最后剩下一个字节填充了 <code>\ u2764</code>，而它对应的是小心形 ❤。</p><p>所以结果是: <code>❤️❤️❤heart</code></p><blockquote><p>PS：您可以使用<a href="https://encoder.internetwache.org/#tab_uni" target="_blank" rel="noopener">此链接</a> 查看 unicode 字符转换</p></blockquote><ul><li><h3 id="4-Object-getOwnPropertyDescriptors"><a href="#4-Object-getOwnPropertyDescriptors" class="headerlink" title="4. Object.getOwnPropertyDescriptors"></a>4. Object.getOwnPropertyDescriptors</h3></li></ul><p>此方法返回给定对象的所有属性的所有详细信息(包括 <code>get</code> <code>set</code> 方法)。主要目的是为了在浅拷贝/克隆一个对象到另一个对象中时，能把 getter 和 setter 也复制过去，因为 <code>Object.assign</code> 无法做到这一点。</p><p><strong>Object.assign 浅克隆除原始源对象的 getter 和 setter 函数以外的所有详细信息。</strong></p><p>以下示例展示了分别使用 <code>Object.assign</code> 和 <code>Object.getOwnPropertyDescriptors</code>（配合 <code>Object.defineProperties</code>） 以将原始对象 <code>Car</code> 复制到新对象 <code>ElectricCar</code> 时的区别。你会发现使用 <code>Object.getOwnPropertyDescriptors</code> 会将 <code>discount</code> 的 getter 和 setter 也被复制到目标对象中。</p><h6 id="之前…"><a href="#之前…" class="headerlink" title="之前…"></a>之前…</h6><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 之前...</span></span><br><span class="line"><span class="keyword">var</span> Car = &#123;</span><br><span class="line">	name: <span class="string">'BMW'</span>,</span><br><span class="line">	price: <span class="number">1000000</span>,</span><br><span class="line">	<span class="keyword">set</span> discount(x) &#123;</span><br><span class="line">		<span class="keyword">this</span>.d = x;</span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="keyword">get</span> discount() &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.d;</span><br><span class="line">	&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印Car对象的“discount”属性的详细信息</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyDescriptor(Car, <span class="string">'discount'</span>));</span><br><span class="line"><span class="comment">// 打印结果..</span></span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">// 	get: [Function: get],</span></span><br><span class="line"><span class="comment">// 	set: [Function: set],</span></span><br><span class="line"><span class="comment">// 	enumerable: true,</span></span><br><span class="line"><span class="comment">// 	configurable: true</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用Object.assign将Car的属性复制到ElectricCar</span></span><br><span class="line"><span class="keyword">const</span> ElectricCar = <span class="built_in">Object</span>.assign(&#123;&#125;, Car)；</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印ElectricCar对象的“discount”属性的详细信息</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyDescriptor(ElectricCar, <span class="string">'discount'</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印</span></span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">// 	value: undefined,</span></span><br><span class="line"><span class="comment">// 	writable: true,</span></span><br><span class="line"><span class="comment">// 	enumerable: true,</span></span><br><span class="line"><span class="comment">// 	configurable: true</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ⚠️ 请注意ElectricCar对象中的“discount”属性中缺少getter和setter！👎👎</span></span><br></pre></td></tr></table></figure><h6 id="以后…"><a href="#以后…" class="headerlink" title="以后…"></a>以后…</h6><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以后...</span></span><br><span class="line"><span class="keyword">var</span> Car = &#123;</span><br><span class="line">	name: <span class="string">'BMW'</span>,</span><br><span class="line">	price: <span class="number">1000000</span>,</span><br><span class="line">	<span class="keyword">set</span> discount(x) &#123;</span><br><span class="line">		<span class="keyword">this</span>.d = x;</span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="keyword">get</span> discount() &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.d;</span><br><span class="line">	&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 使用Object.defineProperties将Car的属性复制到ElectricCar2</span></span><br><span class="line"><span class="comment">// 并使用Object.getOwnPropertyDescriptors提取Car的属性</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ElectricCar2 = <span class="built_in">Object</span>.defineProperties(&#123;&#125;, <span class="built_in">Object</span>.getOwnPropertyDescriptors(Car));</span><br><span class="line"><span class="comment">// 打印ElectricCar2对象“discount”属性的详细信息</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyDescriptor(ElectricCar2, <span class="string">'discount'</span>));</span><br><span class="line"><span class="comment">// prints..</span></span><br><span class="line"><span class="comment">// &#123; get: [Function: get],  👈🏼👈🏼👈🏼</span></span><br><span class="line"><span class="comment">//   set: [Function: set],  👈🏼👈🏼👈🏼</span></span><br><span class="line"><span class="comment">//   enumerable: true,</span></span><br><span class="line"><span class="comment">//   configurable: true</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">// 请注意，getter和setter存在于ElectricCar2对象中，用于'discount'属性！</span></span><br></pre></td></tr></table></figure><ul><li><h3 id="5-在函数参数中添加尾后逗号-trailing-commas"><a href="#5-在函数参数中添加尾后逗号-trailing-commas" class="headerlink" title="5. 在函数参数中添加尾后逗号(trailing commas)"></a>5. 在函数参数中添加尾后逗号(trailing commas)</h3></li></ul><p>这是一个小的更新，它允许我们在最后一个函数参数后面加上尾随逗号。有什么用呢？ 当你使用 git blame 时，这能确保只有新增的参数被显示出来。</p><p>以下示例展示了问题和解决方案:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 问题</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//	#1 开发者创建</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">	name,</span></span></span><br><span class="line"><span class="function"><span class="params">	age</span></span></span><br><span class="line"><span class="function"><span class="params">	</span>) </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">		<span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// #2 开发者添加address</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">	name,</span></span></span><br><span class="line"><span class="function"><span class="params">	age, <span class="regexp">//</span> 添加尾随逗号 	&lt;--------因为逗号，开发人员会被git等工具所警告</span></span></span><br><span class="line"><span class="function"><span class="params">	address <span class="regexp">//</span>添加新的参数</span></span></span><br><span class="line"><span class="function"><span class="params">  </span>) </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">		<span class="keyword">this</span>.age = age;</span><br><span class="line">		<span class="keyword">this</span>.address = address; <span class="comment">//添加的这行</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES2017 解决</span></span><br><span class="line"><span class="comment">// 允许#1开发者添加尾随逗号</span></span><br><span class="line"><span class="comment">// #1 创建如下</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">	name,</span></span></span><br><span class="line"><span class="function"><span class="params">	ange,  <span class="regexp">//</span>&lt;------- 由于尾随逗号，#<span class="number">2</span>开发者不需要改变这行</span></span></span><br><span class="line"><span class="function"><span class="params">	</span>) </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">		<span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：您也可以在调用函数时使用尾后逗号！</p></blockquote><ul><li><h3 id="6-Async-Await"><a href="#6-Async-Await" class="headerlink" title="6. Async/Await"></a>6. Async/Await</h3></li></ul><p>这个特性，在我看来是迄今为止最重要也是最有用的特性。异步函数把我们从回调地狱中解放出来，并使整个代码看起来很简洁。</p><p><code>async</code> 关键字告诉 JavaScript 编译器以不同的方式处理函数，编译器在该函数内到达 <code>await</code> 关键字时暂停。它假设 <code>await</code> 之后的表达式返回一个 Promise，并等到 Promise 被 resolve 或 reject 后才继续前进。</p><p>在下面的例子中，<code>getAmount</code> 函数调用两个异步函数 <code>getUser</code> 和 <code>getBankBalance</code>。我们可以用 Promise 做到这一点，但使用 <code>async await</code> 更优雅和简洁。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不使用</span></span><br><span class="line"><span class="comment">// ES2015 Promise</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getAmount</span>(<span class="params">userId</span>) </span>&#123;</span><br><span class="line">	getUser(userId)</span><br><span class="line">		.then(getBankBalance)</span><br><span class="line">		.then(<span class="function"><span class="params">amount</span> =&gt;</span> &#123;</span><br><span class="line">			<span class="built_in">console</span>.log(amount);</span><br><span class="line">		&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用...</span></span><br><span class="line"><span class="comment">// ES2017</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">getAmount2</span>(<span class="params">userId</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> user = <span class="keyword">await</span> getUser(userId);</span><br><span class="line">	<span class="keyword">var</span> amount = <span class="keyword">await</span> getBankBalance(user);</span><br><span class="line">	<span class="built_in">console</span>.log(amount);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getAmount(<span class="string">'1'</span>); <span class="comment">//$1,000</span></span><br><span class="line"></span><br><span class="line">getAmount2(<span class="string">'1'</span>); <span class="comment">//$1,000</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getUser</span>(<span class="params">userId</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">		setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">			resolve(<span class="string">'john'</span>)</span><br><span class="line">		&#125;, <span class="number">1000</span>)</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getBankBalance</span>(<span class="params">user</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">		setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">			<span class="keyword">if</span>(user == <span class="string">'john'</span>) &#123;</span><br><span class="line">				resolve(<span class="string">'$1,000'</span>);</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				reject(unknown user);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;, <span class="number">1000</span>)</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><h4 id="6-1-异步函数本身返回一个-Promise"><a href="#6-1-异步函数本身返回一个-Promise" class="headerlink" title="6.1 异步函数本身返回一个 Promise"></a>6.1 异步函数本身返回一个 Promise</h4></li></ul><p>如果您要等待异步函数的结果，则需要使用 Promise 的 <code>then</code> 语法来捕获它。</p><p>在下面的例子中，我们想使用 <code>console.log</code> 在 doubleAndAdd 的外部打印出它的结果。所以我们使用 <code>then</code> 来等待并获取它的结果传递给 <code>console.log</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 异步函数本身返回一个Promise</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">doubleAndAdd</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">	a = <span class="keyword">await</span> doubleAfterlSec(a);</span><br><span class="line">	b = <span class="keyword">await</span> doubleAfterlSec(b);</span><br><span class="line">	<span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用法</span></span><br><span class="line">doubleAndAdd(<span class="number">1</span>, <span class="number">2</span>).then(<span class="built_in">console</span>.log);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doubleAfterlSec</span>(<span class="params">param</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span> (<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">		setTimeout(resolve(param * <span class="number">2</span>), <span class="number">1000</span>);</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><h4 id="6-2-并行调用-async-await"><a href="#6-2-并行调用-async-await" class="headerlink" title="6.2 并行调用 async/await"></a>6.2 并行调用 async/await</h4></li></ul><p>在前面的例子中，我们调用了两次 await，每次调用都会等待一秒（总共两秒）。不过既然 <code>a</code> 和 <code>b</code> 没有相互依赖，我们可以使用 <code>Promise.all</code> 来并行调用它们。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 异步函数本身返回一个Promise</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">doubleAndAdd</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">	<span class="comment">//注意：这边使用 Promise.all</span></span><br><span class="line">	<span class="comment">//注意到使用数组解构,捕获结果</span></span><br><span class="line">	[a, b] = <span class="keyword">await</span> <span class="built_in">Promise</span>.all([doubleAfterlSec(a), doubleAfterlSec(b)]);</span><br><span class="line">	<span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用法</span></span><br><span class="line">doubleAndAdd(<span class="number">1</span>, <span class="number">2</span>).then(<span class="built_in">console</span>.log);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doubleAfterlSec</span>(<span class="params">param</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span> (<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">		setTimeout(resolve(param * <span class="number">2</span>), <span class="number">1000</span>);</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><h4 id="6-3-async-await-函数时的错误处理"><a href="#6-3-async-await-函数时的错误处理" class="headerlink" title="6.3 async/await 函数时的错误处理"></a>6.3 async/await 函数时的错误处理</h4></li></ul><p>使用 async await 时有好几种处理错误的方式。</p><blockquote><p>Option 1 - 在函数中使用 try catch</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 使用 try catch</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">doubleAndAdd</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		a = <span class="keyword">await</span> doubleAfterlSec(a);</span><br><span class="line">		b = <span class="keyword">await</span> doubleAfterlSec(b);</span><br><span class="line">	&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NaN</span>; <span class="comment">// return something</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用法</span></span><br><span class="line">doubleAndAdd(<span class="string">'one'</span>, <span class="number">2</span>).then(<span class="built_in">console</span>.log) <span class="comment">//NaN</span></span><br><span class="line">doubleAndAdd(<span class="number">1</span>, <span class="number">2</span>).then(<span class="built_in">console</span>.log) <span class="comment">// 6</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doubleAfterlSec</span>(<span class="params">param</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">		setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">			<span class="keyword">let</span> val = param * <span class="number">2</span>;</span><br><span class="line">			<span class="built_in">isNaN</span>(val) &gt; reject(<span class="literal">NaN</span>) : resolve(val);</span><br><span class="line">		&#125;, <span class="number">1000</span>);</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Option 2 — catch 每一个 await</p></blockquote><p>由于每个 <code>await</code> 表达式都会返回一个 Promise，因此您可以在每行上捕获错误，如下所示。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Option 2 - *Catch* 每个等待线上的错误</span></span><br><span class="line"><span class="comment">// 因为每个等待表达本身就是一个Promise</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">doubleAndAdd</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">	a = <span class="keyword">await</span> doubleAfter1Sec(a).catch(<span class="function"><span class="params">e</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'"a" is NaN'</span>)); <span class="comment">// 👈</span></span><br><span class="line">  b = <span class="keyword">await</span> doubleAfter1Sec(b).catch(<span class="function"><span class="params">e</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'"b" is NaN'</span>)); <span class="comment">// 👈</span></span><br><span class="line">  <span class="keyword">if</span> (!a || !b) &#123;</span><br><span class="line">  	<span class="keyword">return</span> <span class="literal">NaN</span>;</span><br><span class="line">  &#125;</span><br><span class="line">	<span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 用法:</span></span><br><span class="line">doubleAndAdd(<span class="string">'one'</span>, <span class="number">2</span>).then(<span class="built_in">console</span>.log); <span class="comment">// NaN  and logs:  "a" is NaN</span></span><br><span class="line">doubleAndAdd(<span class="number">1</span>, <span class="number">2</span>).then(<span class="built_in">console</span>.log); <span class="comment">// 6</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doubleAfter1Sec</span>(<span class="params">param</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">		setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">			<span class="keyword">let</span> val = param * <span class="number">2</span>;</span><br><span class="line">			<span class="built_in">isNaN</span>(val) ? reject(<span class="literal">NaN</span>) : resolve(val);</span><br><span class="line">		&#125;, <span class="number">1000</span>);</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Option 3 — catch 整个 async-await 函数</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Option 3 - 不要做任何事情，在function外捕获</span></span><br><span class="line"><span class="comment">// 因为异步/等待返回一个Promise，我们可以捕捉整个函数的错误</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">doubleAndAdd</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line"> a = <span class="keyword">await</span> doubleAfter1Sec(a);</span><br><span class="line"> b = <span class="keyword">await</span> doubleAfter1Sec(b);</span><br><span class="line"> <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 用法</span></span><br><span class="line">doubleAndAdd(<span class="string">'one'</span>, <span class="number">2</span>)</span><br><span class="line">.then(<span class="built_in">console</span>.log)</span><br><span class="line">.catch(<span class="built_in">console</span>.log); <span class="comment">// 👈👈🏼&lt;------- use "catch"</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doubleAfter1Sec</span>(<span class="params">param</span>) </span>&#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="keyword">let</span> val = param * <span class="number">2</span>;</span><br><span class="line">   <span class="built_in">isNaN</span>(val) ? reject(<span class="literal">NaN</span>) : resolve(val);</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line"> &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ECMAScript-2018"><a href="#ECMAScript-2018" class="headerlink" title="ECMAScript 2018"></a>ECMAScript 2018</h2><blockquote><p>ECMAScript 目前处于最终草案中，将于 2018 年 6 月或 7 月发布。以下所有特性均在 Stage-4 中，并将成为 ECMAScript 2018 的一部分。</p></blockquote><ul><li><h3 id="1-共享内存和原子操作-Shared-memory-and-atomics"><a href="#1-共享内存和原子操作-Shared-memory-and-atomics" class="headerlink" title="1. 共享内存和原子操作 (Shared memory and atomics)"></a>1. 共享内存和原子操作 (<a href="https://github.com/tc39/ecmascript_sharedme" target="_blank" rel="noopener">Shared memory and atomics</a>)</h3></li></ul><p>这是一个非常先进重大特性，是对 JS 引擎的核心增强。</p><p><strong>主要的想法是为了给 JavaScript 带来一些多线程的特性，允许内存不仅仅由 JS 引擎来管理，而是由 JS 开发者们自行管理，以便将来能够编写高性能、可并发的程序。</strong></p><p>这个特性由一个新的全局对象 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SharedArrayBuffer" target="_blank" rel="noopener">SharedArrayBuffer</a> 实现，它将数据存储在一块<strong>共享内存空间</strong>中。所以这些数据可以在 JS 主线程和 web-worker 线程之间共享。</p><p>到现在为止，如果我们想要在 JS 主线程和 web-worker 之间共享数据，我们必须复制数据并使用 <code>postMessage</code> 将其发送到另一个线程。没别的办法!</p><p>您只需使用 SharedArrayBuffer，数据立马就能同时被主线程和多个 web-worker 线程访问到。</p><p>但在线程之间共享内存可能会导致竞争状况。为了避免竞争条件，又引入了全局对象 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Atomics" target="_blank" rel="noopener">Atomics</a>（原子性）。Atomics 提供了一些方法，用来在一个线程使用共享内存的数据时给共享内存加锁。它还提供了方法来安全地更新共享内存中的（上锁的）数据。</p><blockquote><p>建议通过某个库使用此特性，不过目前没有构建在此功能之上的库。</p></blockquote><p>如果您有兴趣，推荐阅读：</p><ol><li><a href="http://lucasfcosta.com/2017/04/30/JavaScript-From-Workers-to-Shared-Memory.html" target="_blank" rel="noopener">From Workers to Shared Memory</a> — lucasfcosta</li><li><a href="https://hacks.mozilla.org/category/code-cartoons/a-cartoon-intro-to-sharedarraybuffers/" target="_blank" rel="noopener">A cartoon intro to SharedArrayBuffers</a> — Lin Clark</li><li><a href="http://2ality.com/2017/01/shared-array-buffer.html" target="_blank" rel="noopener">Shared memory and atomics</a> — Dr. Axel Rauschmayer</li></ol><ul><li><h3 id="2-移除了带标签的模板字符串的限制"><a href="#2-移除了带标签的模板字符串的限制" class="headerlink" title="2. 移除了带标签的模板字符串的限制"></a>2. 移除了带标签的模板字符串的限制</h3></li></ul><p>首先，我们需要清楚“带标签的模板字符串（Tagged Template literal）”是什么，这样我们可以更好地理解这个特性。</p><p>Tagged template literal 是 ES2015+ 中的特性，它允许开发者自定义如何修改字符串。例如，以标准方式插入字符串，如下所示</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 标准字符串插值</span></span><br><span class="line"><span class="keyword">const</span> firstName = <span class="string">'Raja'</span>;</span><br><span class="line"><span class="keyword">const</span> greetings = <span class="string">`Hello <span class="subst">$&#123;firstName&#125;</span>!`</span>;</span><br><span class="line"><span class="built_in">console</span>.log(greetings); <span class="comment">// "Hello Raja!"</span></span><br></pre></td></tr></table></figure><p>在 tagged template literal 中，你可以编写一个自定义函数（例如<code>greet</code>），它接收字符串文字的硬编码部分(比如 <code>[&#39;Hello&#39;，&#39;！&#39;]</code>）以及要替换的变量（例如[<code>&#39;Raja&#39;]</code>）作为参数，返回值可以是任何东西，由你决定。</p><p>下面的例子展示了我们的自定义“Tag”函数 <code>greet</code> 根据当前时间为模板字符串添加相应的问候语。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// "标记”函数返回一个自定义字符串文字.</span></span><br><span class="line"><span class="comment">// 在这个例子中，greet调用timeGreet（）来追加Good</span></span><br><span class="line"><span class="comment">// Morning/Afternoon/Evening 视当天的时间而定.</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">greet</span>(<span class="params">hardCodedPartsArray, ...replacementPartsArray</span>) </span>&#123;</span><br><span class="line"> <span class="built_in">console</span>.log(hardCodedPartsArray); <span class="comment">//[ 'Hello ', '!' ]</span></span><br><span class="line"> <span class="built_in">console</span>.log(replacementPartsArray); <span class="comment">//[ 'Raja' ]</span></span><br><span class="line"><span class="keyword">let</span> str = <span class="string">''</span>;</span><br><span class="line"> hardCodedPartsArray.forEach(<span class="function">(<span class="params">string, i</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (i &lt; replacementPartsArray.length) &#123;</span><br><span class="line">   str += <span class="string">`<span class="subst">$&#123;string&#125;</span> <span class="subst">$&#123;replacementPartsArray[i] || <span class="string">''</span>&#125;</span>`</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   str += <span class="string">`<span class="subst">$&#123;string&#125;</span> <span class="subst">$&#123;timeGreet()&#125;</span>`</span>; <span class="comment">//&lt;-- 插入 Good morning/afternoon/evening here</span></span><br><span class="line">  &#125;</span><br><span class="line"> &#125;);</span><br><span class="line"> <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用法</span></span><br><span class="line"><span class="keyword">const</span> firstName = <span class="string">'Raja'</span>;</span><br><span class="line"><span class="keyword">const</span> greetings = greet<span class="string">`Hello <span class="subst">$&#123;firstName&#125;</span>!`</span>; <span class="comment">//👈🏼&lt;-- 标记文字</span></span><br><span class="line"><span class="built_in">console</span>.log(greetings); <span class="comment">//'Hello  Raja! Good Morning!' 🔥</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">timeGreet</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="keyword">const</span> hr = <span class="keyword">new</span> <span class="built_in">Date</span>().getHours();</span><br><span class="line"> <span class="keyword">return</span> hr &lt; <span class="number">12</span></span><br><span class="line">  ? <span class="string">'Good Morning!'</span></span><br><span class="line">  : hr &lt; <span class="number">18</span> ? <span class="string">'Good Afternoon!'</span> : <span class="string">'Good Evening!'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我们已经讨论了“标签”函数是什么，许多人想要在不同的域中使用这个功能，比如用于终端命令，或者拼装 HTTP 请求的 URI 等等。</p><p>⚠️ 标记字符串文字的问题</p><p>问题是ES2015和ES2016规范不允许使用“<code>\u</code>”（unicode），“<code>\x</code>”（十六进制）等转义字符，除非它们看起来完全像<code>\u00A9</code>或<code>\uA9A</code>或<code>\xA9</code>。</p><p>因此，如果您有一个内部使用其他域规则（如终端规则）的Tagged函数，那么可能需要使用<strong>\ubla123abla</strong>，它看起来不像<code>\u0049</code>或<code>\u{@F804}</code>，那么您将得到语法错误。</p><p>在ES2018中，只要标记函数返回具有“cooked”属性（其中无效字符为“undefined”）的对象中的值，然后将“raw”属性（与任何你想要的）。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myTagFunc</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line"> <span class="keyword">return</span> &#123; <span class="string">"cooked"</span>: <span class="string">"undefined"</span>, <span class="string">"raw"</span>: str.raw[<span class="number">0</span>] &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> str = myTagFunc <span class="string">`hi \ubla123abla`</span>; <span class="comment">//调用 myTagFunc</span></span><br><span class="line"></span><br><span class="line">str <span class="comment">// &#123; cooked: "undefined", raw: "hi \\unicode" &#125;</span></span><br></pre></td></tr></table></figure><ul><li><h3 id="3-正则表达式的“-”标识"><a href="#3-正则表达式的“-”标识" class="headerlink" title="3. 正则表达式的“.”标识"></a>3. 正则表达式的“.”标识</h3></li></ul><p>目前在正则中，虽然点号（“.”）应该匹配任一单个字符，但其实它无法匹配换行符，如 <code>\n \r \f</code> 等等。</p><p>比如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 之前</span></span><br><span class="line">/first.second/.test(<span class="string">'first\nsecond'</span>); <span class="comment">//false</span></span><br></pre></td></tr></table></figure><p>这项改进使点号可以匹配任何单个字符。为了确保这不会破坏任何内容，我们需要给正则表达式加上 <code>\s</code> 标识它才会生效。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ECMAScript 2018</span></span><br><span class="line">/first.second/s.test(<span class="string">'first\nsecond'</span>); <span class="comment">//true   Notice: /s 👈🏼</span></span><br></pre></td></tr></table></figure><p>以下是<a href="https://github.com/tc39/proposal-regexp-dotall-flag" target="_blank" rel="noopener">提案</a>文档中的 API：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> re = <span class="regexp">/foo.bar/</span>s;</span><br><span class="line"><span class="comment">// 或者 const re = new RegExp('foo.bar', 's');</span></span><br><span class="line"></span><br><span class="line">re.test(<span class="string">'f00\nbar'</span>); <span class="comment">//true</span></span><br><span class="line">re.dotAll <span class="comment">// true</span></span><br><span class="line">re.flags <span class="comment">// 's'</span></span><br></pre></td></tr></table></figure><ul><li><h3 id="4-正则表达式命名组捕获-RegExp-Named-Group-Captures-🔥"><a href="#4-正则表达式命名组捕获-RegExp-Named-Group-Captures-🔥" class="headerlink" title="4. 正则表达式命名组捕获(RegExp Named Group Captures 🔥)"></a>4. 正则表达式命名组捕获(RegExp Named Group Captures 🔥)</h3></li></ul><p>这种增强功能是从其他语言（如Python，Java等）引入的有用特性。称为“命名组”。该特性允许开发者以 <code>(?&lt;name&gt; ...)</code> 的形式为正则表达式中的分组进行命名。然后，他们可以使用该名称轻松获取他们需要的任何分组。</p><ul><li><h4 id="4-1-基本命名组的例子"><a href="#4-1-基本命名组的例子" class="headerlink" title="4.1 基本命名组的例子"></a>4.1 基本命名组的例子</h4></li></ul><p>在下面的示例中，我们使用 <code>(?&lt;year&gt;) (?&lt;month&gt;) 和 (?day)</code> 名称对一个日期正则的不同部分进行分组。结果将会是一个包含 <code>groups</code> 的对象，其值又是一个包含 <code>year</code>，<code>month</code> 和 <code>day</code> 属性的对象，它们的值分别是对应的分组捕获。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 之前</span></span><br><span class="line"><span class="keyword">let</span> re1 = <span class="regexp">/(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)/</span>;</span><br><span class="line"><span class="keyword">let</span> result1 = re1.exec(<span class="string">'2015-01-02'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(result1);</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//["2015-01-02", "2015", "01", "02", index: 0, input: "2015-01-02", groups: undefined]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 以后（ES2018）</span></span><br><span class="line"><span class="keyword">let</span> re2 = <span class="regexp">/(?&lt;year&gt;\d&#123;4&#125;)-(?&lt;month&gt;\d&#123;2&#125;)-(?&lt;day&gt;\d&#123;2&#125;)/u</span>;</span><br><span class="line"><span class="keyword">let</span> result2 = re2.exec(<span class="string">'2015-01-02'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(result2);</span><br><span class="line"><span class="comment">// ["2015-01-02", "2015", "01", "02", index: 0, input: "2015-01-02", groups: &#123; year: '2015', month: '01', day: '02'&#125;]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 用法：</span></span><br><span class="line"><span class="comment">// 你想要知道年份，你可以：</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(result2.groups.year) <span class="comment">//2015</span></span><br></pre></td></tr></table></figure><ul><li><h4 id="4-2-在正则表达式本身内使用命名组"><a href="#4-2-在正则表达式本身内使用命名组" class="headerlink" title="4.2 在正则表达式本身内使用命名组"></a>4.2 在正则表达式本身内使用命名组</h4></li></ul><p>我们可以使用 <code>\k&lt;group name&gt;</code> 格式在正则表达式本身中反向引用该组。以下示例展示了它的用法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//下面例子，有个组叫“fruit”</span></span><br><span class="line"><span class="comment">//它既能匹配“apple”又能匹配“orange”.我们可以使用“\k&lt;group name&gt;”来回引用这个组的结果,(\k&lt;fruit&gt;)</span></span><br><span class="line"><span class="comment">//所以它匹配==两侧的同一个单词</span></span><br><span class="line"><span class="keyword">let</span> sameWords = <span class="regexp">/(?&lt;fruit&gt;apple|orange)==\k&lt;fruit&gt;/u</span>;</span><br><span class="line"></span><br><span class="line">sameWords.test(<span class="string">'apple==apple'</span>);  <span class="comment">//true</span></span><br><span class="line">sameWords.test(<span class="string">'orange==orange'</span>);  <span class="comment">//true</span></span><br><span class="line">sameWords.test(<span class="string">'apple==orange'</span>);  <span class="comment">//false</span></span><br></pre></td></tr></table></figure><ul><li><h4 id="4-3-在-String-prototype-replace-中使用命名组"><a href="#4-3-在-String-prototype-replace-中使用命名组" class="headerlink" title="4.3 在 String.prototype.replace 中使用命名组"></a>4.3 在 String.prototype.replace 中使用命名组</h4></li></ul><p>现在，String 的 <code>replace</code> 实例方法也包含了命名分组的特性。所以我们可以很容易地交换字符串中的单词。</p><p>例如，把 “firstName, lastName” 变成 “lastName, firstName”。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 更换“firstName, lastName” ==&gt; “lastName, firstName”</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> re = <span class="regexp">/(?&lt;firstName&gt;[A-Za-z]+) (?&lt;lastName&gt;[A-Za-z]+$)/u</span>;</span><br><span class="line"></span><br><span class="line"><span class="string">'Raja Rao'</span>.replace(re, <span class="string">'$&lt;lastName&gt;, $&lt;firstName&gt;'</span>); <span class="comment">// "Rao, Raja"</span></span><br></pre></td></tr></table></figure><ul><li><h3 id="5-对象的其余属性-Rest-properties-for-Objects"><a href="#5-对象的其余属性-Rest-properties-for-Objects" class="headerlink" title="5. 对象的其余属性(Rest properties for Objects)"></a>5. 对象的其余属性(Rest properties for Objects)</h3></li></ul><p>rest 操作符 <code>...</code>（三个点）允许我们提取尚未提取的对象属性。</p><ul><li><h4 id="5-1-你可以使用-rest-来帮助只提取你想要的属性"><a href="#5-1-你可以使用-rest-来帮助只提取你想要的属性" class="headerlink" title="5.1 你可以使用 rest 来帮助只提取你想要的属性"></a>5.1 你可以使用 rest 来帮助只提取你想要的属性</h4></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 提取 firstName 和 age</span></span><br><span class="line"><span class="comment">// 将其余的项存储在“remaining”变量中。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123; fristName, age, ...remaining &#125; = &#123;</span><br><span class="line">	fristName: <span class="string">'john'</span>,</span><br><span class="line">	lastName: <span class="string">'smith'</span>,</span><br><span class="line">	age: <span class="number">20</span>,</span><br><span class="line">	height: <span class="string">'5.10'</span>,</span><br><span class="line">	race: <span class="string">'martian'</span>,</span><br><span class="line">&#125;;</span><br><span class="line">firstName; <span class="comment">//john</span></span><br><span class="line">age <span class="comment">//20</span></span><br><span class="line">remaining <span class="comment">//&#123; lastName: 'smith', height: '5.10', race: 'martian' &#125;</span></span><br></pre></td></tr></table></figure><ul><li><h4 id="5-2-更好的是，你可以删除不需要的！🔥🔥"><a href="#5-2-更好的是，你可以删除不需要的！🔥🔥" class="headerlink" title="5.2 更好的是，你可以删除不需要的！🔥🔥"></a>5.2 更好的是，你可以删除不需要的！🔥🔥</h4></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//假设我们想要移除SSN，我们不需要遍历整个对象并创建一个新的cleanObj。</span></span><br><span class="line"><span class="comment">// 简单地使用rest解构来提取出SSN，并将其余的保存在cleanObj中。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123; SSN, ...cleanObj &#125; = &#123;</span><br><span class="line">	firstName: <span class="string">'john'</span>,</span><br><span class="line">	lastName: <span class="string">'smith'</span>,</span><br><span class="line">	SSN: <span class="string">'123-45-6789'</span>,</span><br><span class="line">	race: <span class="string">'martian'</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cleanObj; <span class="comment">//&#123;	firstName: 'john', lastName: 'smith', race: 'martian' &#125;</span></span><br></pre></td></tr></table></figure><ul><li><h3 id="6-展开对象属性-Spread-properties-for-Objects"><a href="#6-展开对象属性-Spread-properties-for-Objects" class="headerlink" title="6. 展开对象属性 (Spread properties for Objects)"></a>6. 展开对象属性 (Spread properties for Objects)</h3></li></ul><p>展开属性看起来就像具有三个点的 Rest 属性一样 <code>...</code>, 但区别在于您使用展开来创建（重新构建）新对象。</p><blockquote><p>提示：展开操作符用于等号的右侧。Rest 用于等号的左侧。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// person 和 account 合并</span></span><br><span class="line"><span class="keyword">const</span> person = &#123; <span class="attr">fName</span>: <span class="string">'john'</span>, <span class="attr">age</span>: <span class="number">20</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> account = &#123; <span class="attr">name</span>: <span class="string">'bofa'</span>, <span class="attr">amount</span>: <span class="string">'$1000'</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过扩展运算符提取person和account的属性，并将其添加到一个新对象中。</span></span><br><span class="line"><span class="keyword">const</span> personAndAccount = &#123; ...person, ...account &#125;;</span><br><span class="line">personAndAccount; <span class="comment">// &#123;fName: 'john', age: 20, name: 'bofa', amount: '$1000' &#125;</span></span><br></pre></td></tr></table></figure><ul><li><h3 id="7-正则表达式的后行断言（零宽后发断言）"><a href="#7-正则表达式的后行断言（零宽后发断言）" class="headerlink" title="7. 正则表达式的后行断言（零宽后发断言）"></a>7. 正则表达式的后行断言（零宽后发断言）</h3></li></ul><p>这是对正则表达式的增强，它允许我们确保某些字符串出现在其他字符串<em>之前</em>。</p><p>您现在可以使用一个组 <code>(?&lt;=...)</code>（问号，小于，等于）来查找肯定正断言。</p><p>此外，您可以使用 <code>(?&lt;!...)</code>（问号，小于，感叹号）来查看否负断言。从本质上讲，只要断言通过，就会匹配。</p><p>正断言：假设我们想要确保 <code>＃</code> 符号在单词 <code>winning</code> 之前存在（即：<code>#winning</code>）并且希望正则表达式只返回字符串“winning”。你可以这样写。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/(?<span class="xml"><span class="tag">&lt;<span class="name">=#).*</span>/<span class="attr">.test</span>('<span class="attr">winning</span>'); // <span class="attr">false</span></span></span></span><br><span class="line"><span class="xml">/(?<span class="tag">&lt;<span class="name">=#).*</span>/<span class="attr">.test</span>('#<span class="attr">winning</span>'); // <span class="attr">true</span></span></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">//之前</span></span><br><span class="line"><span class="xml">'#winning'.match(/#.*/)[0]; // '#wining',包含#</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">//ES2018后</span></span><br><span class="line"><span class="xml">'#winning'.match(/(?<span class="tag">&lt;<span class="name">=#).*</span>/)[<span class="attr">0</span>]; // '<span class="attr">wining</span>' 没有#, #是用来验证的。</span></span></span><br></pre></td></tr></table></figure><p>负断言：假设我们想提取前面是 € 符号而不是 $ 符号的数字。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 3.00不能匹配，因为符号$在前面</span></span><br><span class="line"></span><br><span class="line"><span class="string">'A gallon of milk is $3.00'</span>.match(<span class="regexp">/(?&lt;\$)\d+\.?\d+/</span>); <span class="comment">// null</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.43匹配成功，因为前面没有符号$</span></span><br><span class="line"><span class="comment">//当匹配时，不包含符号€</span></span><br><span class="line"><span class="string">'A gallon of milk is €3.00'</span>.match(<span class="regexp">/(?&lt;\$)\d+\.?\d+/</span>)[<span class="number">0</span>]; <span class="comment">//2.43</span></span><br></pre></td></tr></table></figure><ul><li><h3 id="8-正则表达式-Unicode-属性转义（RegExp-Unicode-Property-Escapes）"><a href="#8-正则表达式-Unicode-属性转义（RegExp-Unicode-Property-Escapes）" class="headerlink" title="8. 正则表达式 Unicode 属性转义（RegExp Unicode Property Escapes）"></a>8. 正则表达式 Unicode 属性转义（<a href="https://github.com/tc39/proposal-regexp-unicode-property-escapes" target="_blank" rel="noopener">RegExp Unicode Property Escapes</a>）</h3></li></ul><p>要编写正则表达式来匹配各种 Unicode 字符并不容易。像 <code>\w</code>，<code>\W</code>，<code>\d</code> 等只能匹配英文字符和数字。但是对于印度语，希腊语等其他语言的数字呢？</p><p>这就是 Unicode Property Escapes 的用武之地。结果是，Unicode 为每个符号（字符）添加了元数据属性，并使用它来对各种符号进行分组或描述各种符号。</p><p>例如，Unicode 数据库将所有印地语字符（हिन्दी）放在一个值为 <code>Devanagari</code> 的 <code>Script</code> 属性，和一个具有相同值 <code>Devanagari</code> 的 <code>Script_Extensions</code>的属性中。所以我们可以搜索 <code>Script=Devanagari</code> 得到所有印地文字符。</p><blockquote><p>Devanagari(梵文)可用于马拉地语，北印度语，梵语等各种印度语言。</p></blockquote><p>从 ECMAScript 2018 开始，我们可以使用 <code>\p</code> 转义字符和 <code>{Script=Devanagari}</code> 来匹配所有印度字符。<strong>也就是说，我们可以在正则表达式中使用：<code>\p{Script=Devanagari}</code> 来匹配所有梵文字符。</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//他跟随匹配多个印地文字符</span></span><br><span class="line">/^\p&#123;Script=Devanagari&#125;+$/u.test(<span class="string">'हिन्दी'</span>); <span class="comment">//true</span></span><br><span class="line"><span class="comment">//PS：有3个印地文字符h</span></span><br></pre></td></tr></table></figure><p>类似地，Unicode 数据库中希腊字符的 <code>Script_Extensions</code>（和<code>Script</code>）值为<code>Greek</code>。所以我们可以使用 <code>Script_Extensions=Greek</code> 或 <code>Script=Greek</code> 来搜索所有希腊字符。</p><p><strong>也就是说，我们可以在正则表达式中使用：<code>\p{Script = Greek}</code> 来匹配所有希腊字符。</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//以下匹配一个希腊字符</span></span><br><span class="line">/\p&#123;Script_Extensions=Greek&#125;/u.test(<span class="string">'π'</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>此外，Unicode 数据库将各种类型的 Emoji 存储在属性值为“true”的布尔属性 <code>Emoji</code>，<code>Emoji_Component</code>，<code>Emoji_Presentation</code>，<code>Emoji_Modifier</code> 和 <code>Emoji_Modifier_Base</code> 下。所以我们可以通过简单地使用 <code>Emoji=true</code> 来查找所有表情符号。</p><p><strong>也就是说，我们可以使用：<code>\p{Emoji}</code>，<code>\Emoji_Modifier</code> 等来匹配各种 Emoji。</strong></p><p>下面的例子将会清楚。<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 下面是匹配表情字符</span></span><br><span class="line">/\p&#123;Emoji&#125;/u.test(<span class="string">'❤️'</span>); <span class="comment">//true</span></span><br><span class="line"><span class="comment">// 下面的操作失败了，因为黄色的emojis没有Emoji_Modifier!</span></span><br><span class="line">/\p&#123;Emoji&#125;\p&#123;Emoji_Modifier&#125;/u.test(<span class="string">'✌️'</span>); <span class="comment">//false</span></span><br><span class="line"><span class="comment">//下面的操作是匹配的，\p&#123;Emoji&#125; 紧跟后面是 \p&#123;Emoji_Modifier&#125;</span></span><br><span class="line">/\p&#123;Emoji&#125;\p&#123;Emoji_Modifier&#125;/u.test(<span class="string">'✌🏽'</span>); <span class="comment">//true</span></span><br><span class="line"><span class="comment">// 解释:</span></span><br><span class="line"><span class="comment">// 默认情况下，胜利表情是黄色的。如果我们使用相同表情的棕色、黑色或其他，它们被认为是原始表情的变体，并使用两个unicode字符表示。一个是原始表情符号，另一个是颜色的unicode字符。在下面的例子中，虽然我们只看到一个棕色的胜利表情符号，但它实际上使用了两个unicode字符，一个用于表情符号，另一个用于棕色。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//在Unicode数据库中，这些颜色具有Emoji_Modifier属性。因此，我们需要使用\p&#123;Emoji&#125;和\p&#123;Emoji_Modifier&#125;来正确和完全匹配棕色的表情符号。</span></span><br><span class="line"></span><br><span class="line">/\p&#123;Emoji&#125;\p&#123;Emoji_Modifier&#125;/u.test(<span class="string">'✌🏽'</span>); <span class="comment">//true</span></span><br></pre></td></tr></table></figure><p></p><p><strong>最后，我们可以使用大写的“P”（<code>\P</code>）转义字符而不是小 p（<code>\p</code>）来否定匹配。</strong></p><p>参考：</p><ol><li><a href="https://mathiasbynens.be/notes/es-unicode-property-escapes" target="_blank" rel="noopener">ECMAScript 2018 Proposal</a></li><li><a href="https://mathiasbynens.be/notes/es-unicode-property-escapes" target="_blank" rel="noopener">https://mathiasbynens.be/notes/es-unicode-property-escapes</a></li></ol><ul><li><h3 id="9-Promise-prototype-finally"><a href="#9-Promise-prototype-finally" class="headerlink" title="9. Promise.prototype.finally()"></a>9. Promise.prototype.finally()</h3></li></ul><p><code>finally()</code> 是 Promise 新增的实例方法。他的主要想法是无论 <code>resolve</code> 或是 <code>reject</code> 后都执行一个回调函数以帮助清理事情。<strong><code>finally</code> 回调被调用时不传入参数，并且无论如何总是被执行。</strong></p><p>我们来看看各种情况:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Resolve</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> started = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">let</span> myPromise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">	resolve(<span class="string">'all good'</span>);</span><br><span class="line">&#125;)</span><br><span class="line">	.then(<span class="function"><span class="params">val</span> =&gt;</span> &#123;</span><br><span class="line">		<span class="built_in">console</span>.log(val); <span class="comment">//all good</span></span><br><span class="line">	&#125;)</span><br><span class="line">	.catch(<span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">		<span class="built_in">console</span>.log(e)l <span class="comment">// 跳过</span></span><br><span class="line">	&#125;)</span><br><span class="line">	.finally(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="string">'This function is always executed!'</span>);</span><br><span class="line">		started = <span class="literal">false</span>; <span class="comment">// 清除</span></span><br><span class="line">	&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Reject</span></span><br><span class="line"><span class="keyword">let</span> started = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">let</span> myPromise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">	resolve(<span class="string">'reject apple'</span>);</span><br><span class="line">&#125;)</span><br><span class="line">	.then(<span class="function"><span class="params">val</span> =&gt;</span> &#123;</span><br><span class="line">		<span class="built_in">console</span>.log(val); <span class="comment">//reject apple</span></span><br><span class="line">	&#125;)</span><br><span class="line">	.catch(<span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">		<span class="built_in">console</span>.log(e)l <span class="comment">//catch被跳过</span></span><br><span class="line">	&#125;)</span><br><span class="line">	.finally(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">		<span class="comment">//注意这里没有任何值</span></span><br><span class="line">		<span class="built_in">console</span>.log(<span class="string">'This function is always executed!'</span>);</span><br><span class="line">		started = <span class="literal">false</span>; <span class="comment">//清除</span></span><br><span class="line">	&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//错误情况1</span></span><br><span class="line"><span class="comment">//Promise 抛出错误</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> started = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">let</span> myPromise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Error'</span>);</span><br><span class="line">&#125;)</span><br><span class="line">	.then(<span class="function"><span class="params">val</span> =&gt;</span> &#123;</span><br><span class="line">		<span class="built_in">console</span>.log(val); <span class="comment">// 跳过</span></span><br><span class="line">	&#125;)</span><br><span class="line">	.catch(<span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">		<span class="built_in">console</span>.log(e)l <span class="comment">// 出现错误catch被调用</span></span><br><span class="line">	&#125;)</span><br><span class="line">	.finally(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">		<span class="comment">// 注意这里没有任何值</span></span><br><span class="line">		<span class="built_in">console</span>.log(<span class="string">'This function is always executed!'</span>);</span><br><span class="line">		started = <span class="literal">false</span>; <span class="comment">// 清除</span></span><br><span class="line">	&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 错误从“catch”事件中抛出</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> started = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">let</span> myPromise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'something happend'</span>);</span><br><span class="line">&#125;)</span><br><span class="line">	.then(<span class="function"><span class="params">val</span> =&gt;</span> &#123;</span><br><span class="line">		<span class="built_in">console</span>.log(val); <span class="comment">// 跳过</span></span><br><span class="line">	&#125;)</span><br><span class="line">	.catch(<span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'throw another error'</span>)</span><br><span class="line">	&#125;)</span><br><span class="line">	.finally(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">		<span class="comment">// 注意这里没有任何值</span></span><br><span class="line">		<span class="built_in">console</span>.log(<span class="string">'This function is always executed!'</span>);</span><br><span class="line">		started = <span class="literal">false</span>; <span class="comment">//清除</span></span><br><span class="line">		<span class="comment">// 错误形式的捕获将需要在其他地方调用函数来处理</span></span><br><span class="line">	&#125;)</span><br></pre></td></tr></table></figure><ul><li><h3 id="10-异步迭代-Asynchronous-Iteration"><a href="#10-异步迭代-Asynchronous-Iteration" class="headerlink" title="10. 异步迭代 (Asynchronous Iteration)"></a>10. 异步迭代 (Asynchronous Iteration)</h3></li></ul><p>这是一个*非常*有用的特性。基本上它允许我们轻松创建异步代码循环！</p><p>这个特性增加了一个新的“for-await-of”循环，允许我们循环调用返回 Promise（或 Promise 数组）的异步函数。很酷的一点是，循环会等待每个 Promise 被 resolve 才进入下一步。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promises = [</span><br><span class="line">	<span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> resolve(<span class="number">1</span>)),</span><br><span class="line">	<span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> resolve(<span class="number">2</span>)),</span><br><span class="line">	<span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> resolve(<span class="number">3</span>)),</span><br><span class="line">]</span><br><span class="line"><span class="comment">// 之前</span></span><br><span class="line"><span class="comment">// for-of使用常规同步迭代器</span></span><br><span class="line"><span class="comment">// 不等待Promise 去解决</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">const</span> obj <span class="keyword">of</span> promise) &#123;</span><br><span class="line">		<span class="built_in">console</span>.log(obj) <span class="comment">// 记录3 条Promise对象</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以后</span></span><br><span class="line"><span class="comment">// for-wait-of使用异步迭代</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> <span class="keyword">await</span> (<span class="keyword">const</span> obj <span class="keyword">of</span> promises) &#123;</span><br><span class="line">		<span class="built_in">console</span>.log(obj); <span class="comment">// 1,2, 3</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test1() <span class="comment">// promise, promise, promise</span></span><br><span class="line">test2() <span class="comment">// 1,2,3</span></span><br></pre></td></tr></table></figure><p>基本上就是这些了！</p></div><div></div><div></div><div><hr><ul class="post-copyright"><li class="post-copyright-authors"> <strong>本文作者：</strong> <a href="https://github.com/sachieyuan">sachieyuan</a> <a href="https://github.com/SevenOutman">SevenOutman</a></li><li class="post-copyright-link"> <strong>本文链接：</strong> <a href="http://blog.rsuitejs.com/2018/04/11/es2016-17-18/" title="ECMAScript 2016, 2017, 和2018中新增功能的示例">http://blog.rsuitejs.com/2018/04/11/es2016-17-18/</a></li><li class="post-copyright-license"> <strong>版权声明：</strong> 本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/3.0/" rel="external nofollow" target="_blank">CC BY-NC-SA 3.0</a> 许可协议。转载请注明出处！</li></ul></div><footer class="post-footer"><div class="post-tags"><a href="/tags/ECMAScript-2016/" rel="tag"><i class="fa fa-tag"></i> ECMAScript 2016</a><a href="/tags/ECMAScript-2017/" rel="tag"><i class="fa fa-tag"></i> ECMAScript 2017</a><a href="/tags/ECMAScript-2018/" rel="tag"><i class="fa fa-tag"></i> ECMAScript 2018</a></div><div class="post-nav"><div class="post-nav-next post-nav-item"><a href="/2018/04/04/webkit-render/" rel="next" title="浏览器渲染引擎"><i class="fa fa-chevron-left"></i> 浏览器渲染引擎</a></div><span class="post-nav-divider"></span><div class="post-nav-prev post-nav-item"> <a href="/2018/04/19/webpack-mutiple-theme-solution/" rel="prev" title="webpack 换肤功能多主题/配色样式打包解决方案">webpack 换肤功能多主题/配色样式打包解决方案<i class="fa fa-chevron-right"></i></a></div></div></footer></article><div class="post-spread"></div></div></div><div class="comments" id="comments"><div id="gitment"></div></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span><span class="sidebar-toggle-line sidebar-toggle-line-middle"></span><span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap"> 文章目录</li><li class="sidebar-nav-overview" data-target="site-overview"> 站点概览</li></ul><section class="site-overview sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person"> <img class="site-author-image" itemprop="image" src="/images/hypers_logo.png" alt="Hypers"><p class="site-author-name" itemprop="name">Hypers</p><p class="site-description motion-element" itemprop="description"></p></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"> <a href="/archives/"><span class="site-state-item-count">24</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"> <a href="/categories/index.html"><span class="site-state-item-count">2</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"> <a href="/tags/index.html"><span class="site-state-item-count">45</span> <span class="site-state-item-name">标签</span></a></div></nav><div class="links-of-author motion-element"></div></section><section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active"><div class="post-toc"><div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#以下是-ECMAScript-2016-2017-和-2018-中新增功能的示例"><span class="nav-number">1.</span> <span class="nav-text">以下是 ECMAScript 2016, 2017, 和 2018 中新增功能的示例</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#ECMAScript-2016"><span class="nav-number">1.1.</span> <span class="nav-text">ECMAScript 2016</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-Array-prototype-includes"><span class="nav-number">1.1.1.</span> <span class="nav-text">1. Array.prototype.includes</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-幂运算符"><span class="nav-number">1.1.2.</span> <span class="nav-text">2. 幂运算符</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ECMAScript-2017"><span class="nav-number">1.2.</span> <span class="nav-text">ECMAScript 2017</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-Object-values"><span class="nav-number">1.2.1.</span> <span class="nav-text">1. Object.values()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-Object-entries"><span class="nav-number">1.2.2.</span> <span class="nav-text">2. Object.entries()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-字符串填充"><span class="nav-number">1.2.3.</span> <span class="nav-text">3. 字符串填充</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-padStart-例子"><span class="nav-number">1.2.3.1.</span> <span class="nav-text">3.1 padStart 例子</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-padEnd-例子"><span class="nav-number">1.2.3.2.</span> <span class="nav-text">3.2 padEnd 例子:</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-⚠️-Emoji-和其他双字节字符上的-padStart-和-padEnd"><span class="nav-number">1.2.3.3.</span> <span class="nav-text">3.3 ⚠️ Emoji 和其他双字节字符上的 padStart 和 padEnd</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-Object-getOwnPropertyDescriptors"><span class="nav-number">1.2.4.</span> <span class="nav-text">4. Object.getOwnPropertyDescriptors</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#之前…"><span class="nav-number">1.2.4.0.0.1.</span> <span class="nav-text">之前…</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#以后…"><span class="nav-number">1.2.4.0.0.2.</span> <span class="nav-text">以后…</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-在函数参数中添加尾后逗号-trailing-commas"><span class="nav-number">1.2.5.</span> <span class="nav-text">5. 在函数参数中添加尾后逗号(trailing commas)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-Async-Await"><span class="nav-number">1.2.6.</span> <span class="nav-text">6. Async/Await</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#6-1-异步函数本身返回一个-Promise"><span class="nav-number">1.2.6.1.</span> <span class="nav-text">6.1 异步函数本身返回一个 Promise</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-2-并行调用-async-await"><span class="nav-number">1.2.6.2.</span> <span class="nav-text">6.2 并行调用 async/await</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-3-async-await-函数时的错误处理"><span class="nav-number">1.2.6.3.</span> <span class="nav-text">6.3 async/await 函数时的错误处理</span></a></li></ol></li></ol><li class="nav-item nav-level-2"><a class="nav-link" href="#ECMAScript-2018"><span class="nav-number">1.3.</span> <span class="nav-text">ECMAScript 2018</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-共享内存和原子操作-Shared-memory-and-atomics"><span class="nav-number">1.3.1.</span> <span class="nav-text">1. 共享内存和原子操作 (Shared memory and atomics)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-移除了带标签的模板字符串的限制"><span class="nav-number">1.3.2.</span> <span class="nav-text">2. 移除了带标签的模板字符串的限制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-正则表达式的“-”标识"><span class="nav-number">1.3.3.</span> <span class="nav-text">3. 正则表达式的“.”标识</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-正则表达式命名组捕获-RegExp-Named-Group-Captures-🔥"><span class="nav-number">1.3.4.</span> <span class="nav-text">4. 正则表达式命名组捕获(RegExp Named Group Captures 🔥)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-1-基本命名组的例子"><span class="nav-number">1.3.4.1.</span> <span class="nav-text">4.1 基本命名组的例子</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-2-在正则表达式本身内使用命名组"><span class="nav-number">1.3.4.2.</span> <span class="nav-text">4.2 在正则表达式本身内使用命名组</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-3-在-String-prototype-replace-中使用命名组"><span class="nav-number">1.3.4.3.</span> <span class="nav-text">4.3 在 String.prototype.replace 中使用命名组</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-对象的其余属性-Rest-properties-for-Objects"><span class="nav-number">1.3.5.</span> <span class="nav-text">5. 对象的其余属性(Rest properties for Objects)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#5-1-你可以使用-rest-来帮助只提取你想要的属性"><span class="nav-number">1.3.5.1.</span> <span class="nav-text">5.1 你可以使用 rest 来帮助只提取你想要的属性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-2-更好的是，你可以删除不需要的！🔥🔥"><span class="nav-number">1.3.5.2.</span> <span class="nav-text">5.2 更好的是，你可以删除不需要的！🔥🔥</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-展开对象属性-Spread-properties-for-Objects"><span class="nav-number">1.3.6.</span> <span class="nav-text">6. 展开对象属性 (Spread properties for Objects)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-正则表达式的后行断言（零宽后发断言）"><span class="nav-number">1.3.7.</span> <span class="nav-text">7. 正则表达式的后行断言（零宽后发断言）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-正则表达式-Unicode-属性转义（RegExp-Unicode-Property-Escapes）"><span class="nav-number">1.3.8.</span> <span class="nav-text">8. 正则表达式 Unicode 属性转义（RegExp Unicode Property Escapes）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-Promise-prototype-finally"><span class="nav-number">1.3.9.</span> <span class="nav-text">9. Promise.prototype.finally()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-异步迭代-Asynchronous-Iteration"><span class="nav-number">1.3.10.</span> <span class="nav-text">10. 异步迭代 (Asynchronous Iteration)</span></a></li></ol></li></div></div></section></div></aside></div></main><footer id="footer" class="footer"><div class="footer-inner"><div class="copyright"> &copy; <span itemprop="copyrightYear">2019</span><span class="with-love"><i class="fa fa-heart"></i></span> <span class="author" itemprop="copyrightHolder">Hypers</span> <span class="post-count">- 全站共56.0k字</span></div><div class="powered-by"> 由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动</div><div class="theme-info"> 主题 - <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a></div></div></footer><div class="back-to-top"><i class="fa fa-arrow-up"></i></div></div><script type="text/javascript">"[object Function]"!==Object.prototype.toString.call(window.Promise)&&(window.Promise=null)</script><script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script><script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script><script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script><script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script><script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script><script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script><script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.1"></script><script type="text/javascript" src="/js/src/post-details.js?v=5.1.1"></script><script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script></body></html>